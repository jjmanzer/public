
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

class yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data 
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__monitor_port',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__monitor_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors', u'channel-monitor', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /channel_monitors/channel_monitor/config/name (leafref)

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /channel_monitors/channel_monitor/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)


  def _get_monitor_port(self):
    """
    Getter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/config/monitor_port (leafref)

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    return self.__monitor_port
      
  def _set_monitor_port(self, v, load=False):
    """
    Setter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/config/monitor_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor_port() directly.

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)""",
        })

    self.__monitor_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor_port(self):
    self.__monitor_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  monitor_port = __builtin__.property(_get_monitor_port, _set_monitor_port)


  _pyangbind_elements = {'name': name, 'monitor_port': monitor_port, }


class yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data 
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__monitor_port',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__monitor_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors', u'channel-monitor', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /channel_monitors/channel_monitor/state/name (leafref)

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /channel_monitors/channel_monitor/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to system-supplied name of the port on the
optical channel monitor (OCM). If this port is embedded
in another card (i.e. an amplifier card) the device
should still define a port representing the OCM even if
it is internal and not physically present on the
faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)


  def _get_monitor_port(self):
    """
    Getter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/state/monitor_port (leafref)

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    return self.__monitor_port
      
  def _set_monitor_port(self, v, load=False):
    """
    Setter method for monitor_port, mapped from YANG variable /channel_monitors/channel_monitor/state/monitor_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor_port() directly.

    YANG Description: Reference to system-supplied name of the port that the
channel monitor is physically connected to. This port
will be of type MONITOR. This port is a tap off of the
monitored-port and would be in the same card as the
monitored port. If this port is embedded in another card
(i.e. an amplifier card) the device should still define
a port representing the monitor port if it is internal
and not physically present on the faceplate of the card
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__monitor_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor_port(self):
    self.__monitor_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="monitor-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)

  name = __builtin__.property(_get_name)
  monitor_port = __builtin__.property(_get_monitor_port)


  _pyangbind_elements = {'name': name, 'monitor_port': monitor_port, }


class yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for PSD
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__lower_frequency','__upper_frequency','__psd',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__psd = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': [u'4']}), is_leaf=True, yang_name="psd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-types:ieeefloat32', is_config=False)
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors', u'channel-monitor', u'channels', u'channel', u'state']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/lower_frequency (oc-opt-types:frequency-type)

    YANG Description: Lower frequency of the specified PSD
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/lower_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Lower frequency of the specified PSD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/upper_frequency (oc-opt-types:frequency-type)

    YANG Description: Upper frequency of the specified PSD
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/upper_frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Upper frequency of the specified PSD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_psd(self):
    """
    Getter method for psd, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/psd (oc-types:ieeefloat32)

    YANG Description: Power spectral density expressed in nanowatts per
megahertz, nW/MHz.  These units allow the value to often
be greater than 1.0.  It also avoids dealing with zero values
for 0dBm.  For example, a 40GHz wide channel
with 0dBm power would be:
 0dBm = 1mW = 10^6nW
 40GHz = 40,000MHz
 0dBm/40GHz = 10^6nW/40,000MHz = 1000/40 = 25
    """
    return self.__psd
      
  def _set_psd(self, v, load=False):
    """
    Setter method for psd, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state/psd (oc-types:ieeefloat32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_psd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_psd() directly.

    YANG Description: Power spectral density expressed in nanowatts per
megahertz, nW/MHz.  These units allow the value to often
be greater than 1.0.  It also avoids dealing with zero values
for 0dBm.  For example, a 40GHz wide channel
with 0dBm power would be:
 0dBm = 1mW = 10^6nW
 40GHz = 40,000MHz
 0dBm/40GHz = 10^6nW/40,000MHz = 1000/40 = 25
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': [u'4']}), is_leaf=True, yang_name="psd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-types:ieeefloat32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """psd must be of a type compatible with oc-types:ieeefloat32""",
          'defined-type': "oc-types:ieeefloat32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': [u'4']}), is_leaf=True, yang_name="psd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-types:ieeefloat32', is_config=False)""",
        })

    self.__psd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_psd(self):
    self.__psd = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': [u'4']}), is_leaf=True, yang_name="psd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='oc-types:ieeefloat32', is_config=False)

  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  psd = __builtin__.property(_get_psd)


  _pyangbind_elements = {'lower_frequency': lower_frequency, 'upper_frequency': upper_frequency, 'psd': psd, }


class yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of tuples describing the PSD distribution
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__lower_frequency','__upper_frequency','__state',)

  _yang_name = 'channel'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__upper_frequency = YANGDynClass(base=unicode, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)
    self.__lower_frequency = YANGDynClass(base=unicode, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors', u'channel-monitor', u'channels', u'channel']

  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/lower_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/lower_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=unicode, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/upper_frequency (leafref)

    YANG Description: Reference to the list key
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/upper_frequency (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: Reference to the list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=unicode, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state (container)

    YANG Description: Operational state data for PSD
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for PSD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=False)

  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = {'lower_frequency': lower_frequency, 'upper_frequency': upper_frequency, 'state': state, }


class yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor/channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of values describing
the power spectral density distribution
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__channel',)

  _yang_name = 'channels'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors', u'channel-monitor', u'channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel (list)

    YANG Description: List of tuples describing the PSD distribution
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /channel_monitors/channel_monitor/channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of tuples describing the PSD distribution
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("lower_frequency upper_frequency",yc_channel_openconfig_channel_monitor__channel_monitors_channel_monitor_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lower-frequency upper-frequency', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = {'channel': channel, }


class yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors/channel-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of channel monitors, keyed by channel monitor name.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__config','__state','__channels',)

  _yang_name = 'channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channels = YANGDynClass(base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors', u'channel-monitor']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /channel_monitors/channel_monitor/name (leafref)

    YANG Description: References the optical channel monitor name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /channel_monitors/channel_monitor/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the optical channel monitor name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /channel_monitors/channel_monitor/config (container)

    YANG Description: Configuration data 
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /channel_monitors/channel_monitor/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_channel_monitor__channel_monitors_channel_monitor_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /channel_monitors/channel_monitor/state (container)

    YANG Description: Operational state data 
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /channel_monitors/channel_monitor/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_channel_monitor__channel_monitors_channel_monitor_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)


  def _get_channels(self):
    """
    Getter method for channels, mapped from YANG variable /channel_monitors/channel_monitor/channels (container)

    YANG Description: Enclosing container for the list of values describing
the power spectral density distribution
    """
    return self.__channels
      
  def _set_channels(self, v, load=False):
    """
    Setter method for channels, mapped from YANG variable /channel_monitors/channel_monitor/channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channels() directly.

    YANG Description: Enclosing container for the list of values describing
the power spectral density distribution
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channels(self):
    self.__channels = YANGDynClass(base=yc_channels_openconfig_channel_monitor__channel_monitors_channel_monitor_channels, is_container='container', yang_name="channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  channels = __builtin__.property(_get_channels, _set_channels)


  _pyangbind_elements = {'name': name, 'config': config, 'state': state, 'channels': channels, }


class yc_channel_monitors_openconfig_channel_monitor__channel_monitors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /channel-monitors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for optical channel monitors
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__channel_monitor',)

  _yang_name = 'channel-monitors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_monitor = YANGDynClass(base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'channel-monitors']

  def _get_channel_monitor(self):
    """
    Getter method for channel_monitor, mapped from YANG variable /channel_monitors/channel_monitor (list)

    YANG Description: List of channel monitors, keyed by channel monitor name.
    """
    return self.__channel_monitor
      
  def _set_channel_monitor(self, v, load=False):
    """
    Setter method for channel_monitor, mapped from YANG variable /channel_monitors/channel_monitor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_monitor() directly.

    YANG Description: List of channel monitors, keyed by channel monitor name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_monitor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)""",
        })

    self.__channel_monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_monitor(self):
    self.__channel_monitor = YANGDynClass(base=YANGListType("name",yc_channel_monitor_openconfig_channel_monitor__channel_monitors_channel_monitor, yang_name="channel-monitor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="channel-monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='list', is_config=True)

  channel_monitor = __builtin__.property(_get_channel_monitor, _set_channel_monitor)


  _pyangbind_elements = {'channel_monitor': channel_monitor, }


class openconfig_channel_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /openconfig-channel-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes operational state data for an optical
channel monitor (OCM) for optical transport line system
elements such as wavelength routers (ROADMs) and amplifiers.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__channel_monitors',)

  _yang_name = 'openconfig-channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_monitors = YANGDynClass(base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_channel_monitors(self):
    """
    Getter method for channel_monitors, mapped from YANG variable /channel_monitors (container)

    YANG Description: Top-level container for optical channel monitors
    """
    return self.__channel_monitors
      
  def _set_channel_monitors(self, v, load=False):
    """
    Setter method for channel_monitors, mapped from YANG variable /channel_monitors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_monitors() directly.

    YANG Description: Top-level container for optical channel monitors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_monitors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__channel_monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_monitors(self):
    self.__channel_monitors = YANGDynClass(base=yc_channel_monitors_openconfig_channel_monitor__channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

  channel_monitors = __builtin__.property(_get_channel_monitors, _set_channel_monitors)


  _pyangbind_elements = {'channel_monitors': channel_monitors, }


