
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

class yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the amplifier
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__target_gain','__target_gain_tilt','__gain_range','__amp_mode','__target_output_power','__enabled','__fiber_type_profile',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/name (string)

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/type (identityref)

    YANG Description: Type of the amplifier
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)


  def _get_target_gain(self):
    """
    Getter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain (decimal64)

    YANG Description: Positive gain applied by the amplifier.
    """
    return self.__target_gain
      
  def _set_target_gain(self, v, load=False):
    """
    Setter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain() directly.

    YANG Description: Positive gain applied by the amplifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__target_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain(self):
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_target_gain_tilt(self):
    """
    Getter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain_tilt (decimal64)

    YANG Description: Gain tilt control
    """
    return self.__target_gain_tilt
      
  def _set_target_gain_tilt(self, v, load=False):
    """
    Setter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_gain_tilt (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain_tilt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain_tilt() directly.

    YANG Description: Gain tilt control
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain_tilt must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__target_gain_tilt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain_tilt(self):
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_gain_range(self):
    """
    Getter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/gain_range (identityref)

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    return self.__gain_range
      
  def _set_gain_range(self, v, load=False):
    """
    Setter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/gain_range (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gain_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gain_range() directly.

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gain_range must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__gain_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gain_range(self):
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)


  def _get_amp_mode(self):
    """
    Getter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/amp_mode (identityref)

    YANG Description: The operating mode of the amplifier
    """
    return self.__amp_mode
      
  def _set_amp_mode(self, v, load=False):
    """
    Setter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/amp_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amp_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amp_mode() directly.

    YANG Description: The operating mode of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amp_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__amp_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amp_mode(self):
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_output_power (decimal64)

    YANG Description: Output optical power of the amplifier.
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Output optical power of the amplifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/enabled (boolean)

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=True)


  def _get_fiber_type_profile(self):
    """
    Getter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/fiber_type_profile (identityref)

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    return self.__fiber_type_profile
      
  def _set_fiber_type_profile(self, v, load=False):
    """
    Setter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config/fiber_type_profile (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fiber_type_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fiber_type_profile() directly.

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fiber_type_profile must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)""",
        })

    self.__fiber_type_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fiber_type_profile(self):
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  target_gain = __builtin__.property(_get_target_gain, _set_target_gain)
  target_gain_tilt = __builtin__.property(_get_target_gain_tilt, _set_target_gain_tilt)
  gain_range = __builtin__.property(_get_gain_range, _set_gain_range)
  amp_mode = __builtin__.property(_get_amp_mode, _set_amp_mode)
  target_output_power = __builtin__.property(_get_target_output_power, _set_target_output_power)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  fiber_type_profile = __builtin__.property(_get_fiber_type_profile, _set_fiber_type_profile)


  _pyangbind_elements = {'name': name, 'type': type, 'target_gain': target_gain, 'target_gain_tilt': target_gain_tilt, 'gain_range': gain_range, 'amp_mode': amp_mode, 'target_output_power': target_output_power, 'enabled': enabled, 'fiber_type_profile': fiber_type_profile, }


class yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/actual-gain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The actual gain applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'actual-gain'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'actual-gain']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/actual-gain-tilt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The actual tilt applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'actual-gain-tilt'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'actual-gain-tilt']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/input-power-total. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The total input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'input-power-total'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'input-power-total']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/input-power-c-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'input-power-c-band'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'input-power-c-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/input-power-l-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'input-power-l-band'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'input-power-l-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/output-power-total. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'output-power-total'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'output-power-total']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/output-power-c-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'output-power-c-band'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'output-power-c-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/output-power-l-band. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'output-power-l-band'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'output-power-l-band']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. If avg/min/max statistics
are not supported, just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'laser-bias-current'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state/optical-return-loss. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-return-loss'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state', u'optical-return-loss']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the amplifier
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__type','__target_gain','__target_gain_tilt','__gain_range','__amp_mode','__target_output_power','__enabled','__fiber_type_profile','__component','__ingress_port','__egress_port','__actual_gain','__actual_gain_tilt','__input_power_total','__input_power_c_band','__input_power_l_band','__output_power_total','__output_power_c_band','__output_power_l_band','__laser_bias_current','__optical_return_loss',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_return_loss = YANGDynClass(base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__ingress_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__output_power_total = YANGDynClass(base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__actual_gain = YANGDynClass(base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__egress_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    self.__input_power_c_band = YANGDynClass(base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__component = YANGDynClass(base=unicode, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__input_power_total = YANGDynClass(base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)
    self.__output_power_c_band = YANGDynClass(base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)
    self.__output_power_l_band = YANGDynClass(base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__actual_gain_tilt = YANGDynClass(base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__input_power_l_band = YANGDynClass(base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/name (string)

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: User-defined name assigned to identify a specific amplifier
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='string', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/type (identityref)

    YANG Description: Type of the amplifier
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HYBRID': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'EDFA': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:BACKWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FORWARD_RAMAN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_target_gain(self):
    """
    Getter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain (decimal64)

    YANG Description: Positive gain applied by the amplifier.
    """
    return self.__target_gain
      
  def _set_target_gain(self, v, load=False):
    """
    Setter method for target_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain() directly.

    YANG Description: Positive gain applied by the amplifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__target_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain(self):
    self.__target_gain = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': [u'0..max']}), is_leaf=True, yang_name="target-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_target_gain_tilt(self):
    """
    Getter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain_tilt (decimal64)

    YANG Description: Gain tilt control
    """
    return self.__target_gain_tilt
      
  def _set_target_gain_tilt(self, v, load=False):
    """
    Setter method for target_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_gain_tilt (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_gain_tilt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_gain_tilt() directly.

    YANG Description: Gain tilt control
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_gain_tilt must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__target_gain_tilt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_gain_tilt(self):
    self.__target_gain_tilt = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_gain_range(self):
    """
    Getter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/gain_range (identityref)

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    return self.__gain_range
      
  def _set_gain_range(self, v, load=False):
    """
    Setter method for gain_range, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/gain_range (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gain_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gain_range() directly.

    YANG Description: Selected gain range.  The gain range is a platform-defined
value indicating the switched gain amplifier setting
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gain_range must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__gain_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gain_range(self):
    self.__gain_range = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LOW_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'HIGH_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:FIXED_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:MID_GAIN_RANGE': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="gain-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_amp_mode(self):
    """
    Getter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/amp_mode (identityref)

    YANG Description: The operating mode of the amplifier
    """
    return self.__amp_mode
      
  def _set_amp_mode(self, v, load=False):
    """
    Setter method for amp_mode, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/amp_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amp_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amp_mode() directly.

    YANG Description: The operating mode of the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amp_mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__amp_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amp_mode(self):
    self.__amp_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_POWER': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:CONSTANT_GAIN': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="amp-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_output_power (decimal64)

    YANG Description: Output optical power of the amplifier.
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Output optical power of the amplifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/enabled (boolean)

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Turns power on / off to the amplifiers gain module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='boolean', is_config=False)


  def _get_fiber_type_profile(self):
    """
    Getter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/fiber_type_profile (identityref)

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    return self.__fiber_type_profile
      
  def _set_fiber_type_profile(self, v, load=False):
    """
    Setter method for fiber_type_profile, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/fiber_type_profile (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fiber_type_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fiber_type_profile() directly.

    YANG Description: The fiber type profile specifies details about the
fiber type which are needed to accurately determine
the gain and perform efficient amplification. This is
only needed for Raman type amplifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fiber_type_profile must be of a type compatible with identityref""",
          'defined-type': "openconfig-optical-amplifier:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)""",
        })

    self.__fiber_type_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fiber_type_profile(self):
    self.__fiber_type_profile = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'DSF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:LEAF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWRS': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'SSMF': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}, u'oc-opt-amp:TWC': {'@namespace': u'http://openconfig.net/yang/optical-amplfier', '@module': u'openconfig-optical-amplifier'}},), is_leaf=True, yang_name="fiber-type-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='identityref', is_config=False)


  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/component (leafref)

    YANG Description: Reference to the system-supplied physical component that
the amplifier gain block is contained within. Multiple
amplifier gain blocks may be contained within the same
physical component.
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/component (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.

    YANG Description: Reference to the system-supplied physical component that
the amplifier gain block is contained within. Multiple
amplifier gain blocks may be contained within the same
physical component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=unicode, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)


  def _get_ingress_port(self):
    """
    Getter method for ingress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/ingress_port (leafref)

    YANG Description: Reference to system-supplied name of the amplifier ingress
port. This leaf is only valid for ports of type INGRESS.
    """
    return self.__ingress_port
      
  def _set_ingress_port(self, v, load=False):
    """
    Setter method for ingress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/ingress_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress_port() directly.

    YANG Description: Reference to system-supplied name of the amplifier ingress
port. This leaf is only valid for ports of type INGRESS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)""",
        })

    self.__ingress_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress_port(self):
    self.__ingress_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="ingress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)


  def _get_egress_port(self):
    """
    Getter method for egress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/egress_port (leafref)

    YANG Description: Reference to system-supplied name of the amplifier egress
port. This leaf is only valid for ports of type EGRESS.
    """
    return self.__egress_port
      
  def _set_egress_port(self, v, load=False):
    """
    Setter method for egress_port, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/egress_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egress_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egress_port() directly.

    YANG Description: Reference to system-supplied name of the amplifier egress
port. This leaf is only valid for ports of type EGRESS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egress_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)""",
        })

    self.__egress_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egress_port(self):
    self.__egress_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="egress-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=False)


  def _get_actual_gain(self):
    """
    Getter method for actual_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain (container)

    YANG Description: The actual gain applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__actual_gain
      
  def _set_actual_gain(self, v, load=False):
    """
    Setter method for actual_gain, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actual_gain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actual_gain() directly.

    YANG Description: The actual gain applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """actual_gain must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__actual_gain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_actual_gain(self):
    self.__actual_gain = YANGDynClass(base=yc_actual_gain_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain, is_container='container', yang_name="actual-gain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_actual_gain_tilt(self):
    """
    Getter method for actual_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt (container)

    YANG Description: The actual tilt applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__actual_gain_tilt
      
  def _set_actual_gain_tilt(self, v, load=False):
    """
    Setter method for actual_gain_tilt, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/actual_gain_tilt (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actual_gain_tilt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actual_gain_tilt() directly.

    YANG Description: The actual tilt applied by the amplifier in units of
0.01dB. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """actual_gain_tilt must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__actual_gain_tilt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_actual_gain_tilt(self):
    self.__actual_gain_tilt = YANGDynClass(base=yc_actual_gain_tilt_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_actual_gain_tilt, is_container='container', yang_name="actual-gain-tilt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_input_power_total(self):
    """
    Getter method for input_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total (container)

    YANG Description: The total input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__input_power_total
      
  def _set_input_power_total(self, v, load=False):
    """
    Setter method for input_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power_total() directly.

    YANG Description: The total input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power_total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power_total(self):
    self.__input_power_total = YANGDynClass(base=yc_input_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_total, is_container='container', yang_name="input-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_input_power_c_band(self):
    """
    Getter method for input_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band (container)

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__input_power_c_band
      
  def _set_input_power_c_band(self, v, load=False):
    """
    Setter method for input_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_c_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power_c_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power_c_band() directly.

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power_c_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power_c_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power_c_band(self):
    self.__input_power_c_band = YANGDynClass(base=yc_input_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_c_band, is_container='container', yang_name="input-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_input_power_l_band(self):
    """
    Getter method for input_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band (container)

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__input_power_l_band
      
  def _set_input_power_l_band(self, v, load=False):
    """
    Setter method for input_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/input_power_l_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power_l_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power_l_band() directly.

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm) input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power_l_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power_l_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power_l_band(self):
    self.__input_power_l_band = YANGDynClass(base=yc_input_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_input_power_l_band, is_container='container', yang_name="input-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power_total(self):
    """
    Getter method for output_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total (container)

    YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_total
      
  def _set_output_power_total(self, v, load=False):
    """
    Setter method for output_power_total, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_total (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_total() directly.

    YANG Description: The total output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_total must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_total(self):
    self.__output_power_total = YANGDynClass(base=yc_output_power_total_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_total, is_container='container', yang_name="output-power-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power_c_band(self):
    """
    Getter method for output_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band (container)

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_c_band
      
  def _set_output_power_c_band(self, v, load=False):
    """
    Setter method for output_power_c_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_c_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_c_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_c_band() directly.

    YANG Description: The C band (consisting of approximately 191 to 195 THz or
1530nm to 1565 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_c_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power_c_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_c_band(self):
    self.__output_power_c_band = YANGDynClass(base=yc_output_power_c_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_c_band, is_container='container', yang_name="output-power-c-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power_l_band(self):
    """
    Getter method for output_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band (container)

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    return self.__output_power_l_band
      
  def _set_output_power_l_band(self, v, load=False):
    """
    Setter method for output_power_l_band, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/output_power_l_band (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power_l_band is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power_l_band() directly.

    YANG Description: The L band (consisting of approximately 184 to 191 THz or
1565 to 1625 nm)output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power_l_band must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power_l_band = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power_l_band(self):
    self.__output_power_l_band = YANGDynClass(base=yc_output_power_l_band_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_output_power_l_band, is_container='container', yang_name="output-power-l-band", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. If avg/min/max statistics
are not supported, just supply the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. If avg/min/max statistics
are not supported, just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_optical_return_loss(self):
    """
    Getter method for optical_return_loss, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss (container)

    YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value
    """
    return self.__optical_return_loss
      
  def _set_optical_return_loss(self, v, load=False):
    """
    Setter method for optical_return_loss, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state/optical_return_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_return_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_return_loss() directly.

    YANG Description: The optical return loss (ORL) is the ratio of the light
reflected back into the port to the light launched out of
the port. ORL is in units of 0.01dBm. If avg/min/max
statistics are not supported, just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_return_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__optical_return_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_return_loss(self):
    self.__optical_return_loss = YANGDynClass(base=yc_optical_return_loss_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state_optical_return_loss, is_container='container', yang_name="optical-return-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  type = __builtin__.property(_get_type)
  target_gain = __builtin__.property(_get_target_gain)
  target_gain_tilt = __builtin__.property(_get_target_gain_tilt)
  gain_range = __builtin__.property(_get_gain_range)
  amp_mode = __builtin__.property(_get_amp_mode)
  target_output_power = __builtin__.property(_get_target_output_power)
  enabled = __builtin__.property(_get_enabled)
  fiber_type_profile = __builtin__.property(_get_fiber_type_profile)
  component = __builtin__.property(_get_component)
  ingress_port = __builtin__.property(_get_ingress_port)
  egress_port = __builtin__.property(_get_egress_port)
  actual_gain = __builtin__.property(_get_actual_gain)
  actual_gain_tilt = __builtin__.property(_get_actual_gain_tilt)
  input_power_total = __builtin__.property(_get_input_power_total)
  input_power_c_band = __builtin__.property(_get_input_power_c_band)
  input_power_l_band = __builtin__.property(_get_input_power_l_band)
  output_power_total = __builtin__.property(_get_output_power_total)
  output_power_c_band = __builtin__.property(_get_output_power_c_band)
  output_power_l_band = __builtin__.property(_get_output_power_l_band)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  optical_return_loss = __builtin__.property(_get_optical_return_loss)


  _pyangbind_elements = {'name': name, 'type': type, 'target_gain': target_gain, 'target_gain_tilt': target_gain_tilt, 'gain_range': gain_range, 'amp_mode': amp_mode, 'target_output_power': target_output_power, 'enabled': enabled, 'fiber_type_profile': fiber_type_profile, 'component': component, 'ingress_port': ingress_port, 'egress_port': egress_port, 'actual_gain': actual_gain, 'actual_gain_tilt': actual_gain_tilt, 'input_power_total': input_power_total, 'input_power_c_band': input_power_c_band, 'input_power_l_band': input_power_l_band, 'output_power_total': output_power_total, 'output_power_c_band': output_power_c_band, 'output_power_l_band': output_power_l_band, 'laser_bias_current': laser_bias_current, 'optical_return_loss': optical_return_loss, }


class yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers/amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of optical amplifiers present in the device
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__config','__state',)

  _yang_name = 'amplifier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers', u'amplifier']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/name (leafref)

    YANG Description: Reference to the name of the amplifier
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the amplifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config (container)

    YANG Description: Configuration data for the amplifier
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state (container)

    YANG Description: Operational state data for the amplifier
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /optical_amplifier/amplifiers/amplifier/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the amplifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'name': name, 'config': config, 'state': state, }


class yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/amplifiers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of amplifiers
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__amplifier',)

  _yang_name = 'amplifiers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__amplifier = YANGDynClass(base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'amplifiers']

  def _get_amplifier(self):
    """
    Getter method for amplifier, mapped from YANG variable /optical_amplifier/amplifiers/amplifier (list)

    YANG Description: List of optical amplifiers present in the device
    """
    return self.__amplifier
      
  def _set_amplifier(self, v, load=False):
    """
    Setter method for amplifier, mapped from YANG variable /optical_amplifier/amplifiers/amplifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amplifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amplifier() directly.

    YANG Description: List of optical amplifiers present in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amplifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)""",
        })

    self.__amplifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amplifier(self):
    self.__amplifier = YANGDynClass(base=YANGListType("name",yc_amplifier_openconfig_optical_amplifier__optical_amplifier_amplifiers_amplifier, yang_name="amplifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

  amplifier = __builtin__.property(_get_amplifier, _set_amplifier)


  _pyangbind_elements = {'amplifier': amplifier, }


class yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for OSCs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__interface',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels', u'supervisory-channel', u'config']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config/interface (oc-if:base-interface-ref)

    YANG Description: Reference to an OSC interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to an OSC interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)


  _pyangbind_elements = {'interface': interface, }


class yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state/input-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'input-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels', u'supervisory-channel', u'state', u'input-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state/output-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'output-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels', u'supervisory-channel', u'state', u'output-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state/laser-bias-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to one decimal precision. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'laser-bias-current'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels', u'supervisory-channel', u'state', u'laser-bias-current']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for OSCs
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__interface','__input_power','__output_power','__laser_bias_current',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels', u'supervisory-channel', u'state']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/interface (oc-if:base-interface-ref)

    YANG Description: Reference to an OSC interface
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/interface (oc-if:base-interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to an OSC interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with oc-if:base-interface-ref""",
          'defined-type': "oc-if:base-interface-ref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='oc-if:base-interface-ref', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power (container)

    YANG Description: The input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=yc_input_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power (container)

    YANG Description: The output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of this port in units
of 0.01dBm. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=yc_output_power_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to one decimal precision. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to one decimal precision. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=yc_laser_bias_current_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state_laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=False)

  interface = __builtin__.property(_get_interface)
  input_power = __builtin__.property(_get_input_power)
  output_power = __builtin__.property(_get_output_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)


  _pyangbind_elements = {'interface': interface, 'input_power': input_power, 'output_power': output_power, 'laser_bias_current': laser_bias_current, }


class yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels/supervisory-channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of supervisory channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__interface','__config','__state',)

  _yang_name = 'supervisory-channel'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels', u'supervisory-channel']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/interface (leafref)

    YANG Description: Reference to the interface of the supervisory channel
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Reference to the interface of the supervisory channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config (container)

    YANG Description: Configuration data for OSCs
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for OSCs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state (container)

    YANG Description: Operational state data for OSCs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for OSCs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'interface': interface, 'config': config, 'state': state, }


class yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier/supervisory-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of supervisory channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__supervisory_channel',)

  _yang_name = 'supervisory-channels'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supervisory_channel = YANGDynClass(base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier', u'supervisory-channels']

  def _get_supervisory_channel(self):
    """
    Getter method for supervisory_channel, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel (list)

    YANG Description: List of supervisory channels
    """
    return self.__supervisory_channel
      
  def _set_supervisory_channel(self, v, load=False):
    """
    Setter method for supervisory_channel, mapped from YANG variable /optical_amplifier/supervisory_channels/supervisory_channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supervisory_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supervisory_channel() directly.

    YANG Description: List of supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supervisory_channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)""",
        })

    self.__supervisory_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supervisory_channel(self):
    self.__supervisory_channel = YANGDynClass(base=YANGListType("interface",yc_supervisory_channel_openconfig_optical_amplifier__optical_amplifier_supervisory_channels_supervisory_channel, yang_name="supervisory-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface', extensions=None), is_container='list', yang_name="supervisory-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='list', is_config=True)

  supervisory_channel = __builtin__.property(_get_supervisory_channel, _set_supervisory_channel)


  _pyangbind_elements = {'supervisory_channel': supervisory_channel, }


class yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /optical-amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for amplifiers and supervisory channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__amplifiers','__supervisory_channels',)

  _yang_name = 'optical-amplifier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supervisory_channels = YANGDynClass(base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    self.__amplifiers = YANGDynClass(base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'optical-amplifier']

  def _get_amplifiers(self):
    """
    Getter method for amplifiers, mapped from YANG variable /optical_amplifier/amplifiers (container)

    YANG Description: Enclosing container for list of amplifiers
    """
    return self.__amplifiers
      
  def _set_amplifiers(self, v, load=False):
    """
    Setter method for amplifiers, mapped from YANG variable /optical_amplifier/amplifiers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_amplifiers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_amplifiers() directly.

    YANG Description: Enclosing container for list of amplifiers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """amplifiers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__amplifiers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_amplifiers(self):
    self.__amplifiers = YANGDynClass(base=yc_amplifiers_openconfig_optical_amplifier__optical_amplifier_amplifiers, is_container='container', yang_name="amplifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)


  def _get_supervisory_channels(self):
    """
    Getter method for supervisory_channels, mapped from YANG variable /optical_amplifier/supervisory_channels (container)

    YANG Description: Enclosing container for list of supervisory channels
    """
    return self.__supervisory_channels
      
  def _set_supervisory_channels(self, v, load=False):
    """
    Setter method for supervisory_channels, mapped from YANG variable /optical_amplifier/supervisory_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supervisory_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supervisory_channels() directly.

    YANG Description: Enclosing container for list of supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supervisory_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__supervisory_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supervisory_channels(self):
    self.__supervisory_channels = YANGDynClass(base=yc_supervisory_channels_openconfig_optical_amplifier__optical_amplifier_supervisory_channels, is_container='container', yang_name="supervisory-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  amplifiers = __builtin__.property(_get_amplifiers, _set_amplifiers)
  supervisory_channels = __builtin__.property(_get_supervisory_channels, _set_supervisory_channels)


  _pyangbind_elements = {'amplifiers': amplifiers, 'supervisory_channels': supervisory_channels, }


class openconfig_optical_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /openconfig-optical-amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical amplifiers, deployed as part of a transport
line system.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__optical_amplifier',)

  _yang_name = 'openconfig-optical-amplifier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_amplifier = YANGDynClass(base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_amplifier(self):
    """
    Getter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    return self.__optical_amplifier
      
  def _set_optical_amplifier(self, v, load=False):
    """
    Setter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_amplifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_amplifier() directly.

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_amplifier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__optical_amplifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_amplifier(self):
    self.__optical_amplifier = YANGDynClass(base=yc_optical_amplifier_openconfig_optical_amplifier__optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  optical_amplifier = __builtin__.property(_get_optical_amplifier, _set_optical_amplifier)


  _pyangbind_elements = {'optical_amplifier': optical_amplifier, }


