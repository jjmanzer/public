
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for logical channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__description','__admin_state','__rate_class','__trib_protocol','__logical_channel_type','__loopback_mode','__test_signal',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/config/index (uint32)

    YANG Description: Index of the current logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/config/description (string)

    YANG Description: Description of the logical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/config/admin_state (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin state of the logical channel
    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/config/admin_state (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: Sets the admin state of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=True)


  def _get_rate_class(self):
    """
    Getter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/config/rate_class (identityref)

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    return self.__rate_class
      
  def _set_rate_class(self, v, load=False):
    """
    Setter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/config/rate_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_class() directly.

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__rate_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_class(self):
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_trib_protocol(self):
    """
    Getter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/config/trib_protocol (identityref)

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    return self.__trib_protocol
      
  def _set_trib_protocol(self, v, load=False):
    """
    Setter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/config/trib_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trib_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trib_protocol() directly.

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trib_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__trib_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trib_protocol(self):
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_logical_channel_type(self):
    """
    Getter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/config/logical_channel_type (identityref)

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    return self.__logical_channel_type
      
  def _set_logical_channel_type(self, v, load=False):
    """
    Setter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/config/logical_channel_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_type() directly.

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)""",
        })

    self.__logical_channel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_type(self):
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=True)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/config/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=True)


  def _get_test_signal(self):
    """
    Getter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/config/test_signal (boolean)

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    return self.__test_signal
      
  def _set_test_signal(self, v, load=False):
    """
    Setter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/config/test_signal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_signal() directly.

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_signal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__test_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_signal(self):
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  admin_state = __builtin__.property(_get_admin_state, _set_admin_state)
  rate_class = __builtin__.property(_get_rate_class, _set_rate_class)
  trib_protocol = __builtin__.property(_get_trib_protocol, _set_trib_protocol)
  logical_channel_type = __builtin__.property(_get_logical_channel_type, _set_logical_channel_type)
  loopback_mode = __builtin__.property(_get_loopback_mode, _set_loopback_mode)
  test_signal = __builtin__.property(_get_test_signal, _set_test_signal)


  _pyangbind_elements = {'index': index, 'description': description, 'admin_state': admin_state, 'rate_class': rate_class, 'trib_protocol': trib_protocol, 'logical_channel_type': logical_channel_type, 'loopback_mode': loopback_mode, 'test_signal': test_signal, }


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for logical channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__description','__admin_state','__rate_class','__trib_protocol','__logical_channel_type','__loopback_mode','__test_signal','__link_state',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__link_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/state/index (uint32)

    YANG Description: Index of the current logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/state/description (string)

    YANG Description: Description of the logical channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/admin_state (oc-opt-types:admin-state-type)

    YANG Description: Sets the admin state of the logical channel
    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/admin_state (oc-opt-types:admin-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: Sets the admin state of the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with oc-opt-types:admin-state-type""",
          'defined-type': "oc-opt-types:admin-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MAINT': {}, u'ENABLED': {}},), is_leaf=True, yang_name="admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:admin-state-type', is_config=False)


  def _get_rate_class(self):
    """
    Getter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/state/rate_class (identityref)

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    return self.__rate_class
      
  def _set_rate_class(self, v, load=False):
    """
    Setter method for rate_class, mapped from YANG variable /terminal_device/logical_channels/channel/state/rate_class (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_class is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_class() directly.

    YANG Description: Rounded bit rate of the tributary signal. Exact bit rate
will be refined by protocol selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_class must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__rate_class = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_class(self):
    self.__rate_class = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_200G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_400G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_250G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_150G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_1G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_2.5G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_10G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_40G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:TRIB_RATE_300G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'TRIB_RATE_100G': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="rate-class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_trib_protocol(self):
    """
    Getter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/state/trib_protocol (identityref)

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    return self.__trib_protocol
      
  def _set_trib_protocol(self, v, load=False):
    """
    Setter method for trib_protocol, mapped from YANG variable /terminal_device/logical_channels/channel/state/trib_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trib_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trib_protocol() directly.

    YANG Description: Protocol framing of the tributary signal. If this
LogicalChannel is directly connected to a Client-Port or
Optical-Channel, this is the protocol of the associated port.
If the LogicalChannel is connected to other LogicalChannels,
the TributaryProtocol of the LogicalChannels will define a
specific mapping/demapping or multiplexing/demultiplexing
function.

Not all protocols are valid, depending on the value
of trib-rate-class.  The expectation is that the NMS
will validate that a correct combination of rate class
and protocol are specfied.  Basic combinations are:

rate class: 1G
protocols: 1GE

rate class: 2.5G
protocols: OC48, STM16

rate class: 10G
protocols:  10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
           OTU1e, ODU2, ODU2e, ODU1e

rate class: 40G
protocols:  40GE, OC768, STM256, OTU3, ODU3

rate class: 100G
protocols:  100GE, 100G MLG, OTU4, OTUCn, ODU4
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trib_protocol must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__trib_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trib_protocol(self):
    self.__trib_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_WAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTUCN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_1GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM16': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OC192': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_40GE': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_STM256': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_10GE_LAN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC768': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_100G_MLG': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU3': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU2': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ODU4': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_STM64': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTU1E': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OC48': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="trib-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_logical_channel_type(self):
    """
    Getter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/state/logical_channel_type (identityref)

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    return self.__logical_channel_type
      
  def _set_logical_channel_type(self, v, load=False):
    """
    Setter method for logical_channel_type, mapped from YANG variable /terminal_device/logical_channels/channel/state/logical_channel_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_type() directly.

    YANG Description: The type / stage of the logical element determines the
configuration and operational state parameters (PMs)
available for the logical element
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-terminal-device:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)""",
        })

    self.__logical_channel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_type(self):
    self.__logical_channel_type = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-opt-types:PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'oc-opt-types:PROT_OTN': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}, u'PROT_ETHERNET': {'@namespace': u'http://openconfig.net/yang/transport-types', '@module': u'openconfig-transport-types'}},), is_leaf=True, yang_name="logical-channel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='identityref', is_config=False)


  def _get_loopback_mode(self):
    """
    Getter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/loopback_mode (oc-opt-types:loopback-mode-type)

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    return self.__loopback_mode
      
  def _set_loopback_mode(self, v, load=False):
    """
    Setter method for loopback_mode, mapped from YANG variable /terminal_device/logical_channels/channel/state/loopback_mode (oc-opt-types:loopback-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loopback_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loopback_mode() directly.

    YANG Description: Sets the loopback type on the logical channel. Setting the
mode to something besides NONE activates the loopback in
the specified mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loopback_mode must be of a type compatible with oc-opt-types:loopback-mode-type""",
          'defined-type': "oc-opt-types:loopback-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)""",
        })

    self.__loopback_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loopback_mode(self):
    self.__loopback_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TERMINAL': {}, u'NONE': {}, u'FACILITY': {}},), default=unicode("NONE"), is_leaf=True, yang_name="loopback-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:loopback-mode-type', is_config=False)


  def _get_test_signal(self):
    """
    Getter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/state/test_signal (boolean)

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    return self.__test_signal
      
  def _set_test_signal(self, v, load=False):
    """
    Setter method for test_signal, mapped from YANG variable /terminal_device/logical_channels/channel/state/test_signal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_signal() directly.

    YANG Description: When enabled the logical channel's DSP will generate a pseudo
randmon bit stream (PRBS) which can be used during testing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_signal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__test_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_signal(self):
    self.__test_signal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="test-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_link_state(self):
    """
    Getter method for link_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/link_state (enumeration)

    YANG Description: Link-state of the Ethernet protocol on the logical channel,
SONET / SDH framed signal, etc.
    """
    return self.__link_state
      
  def _set_link_state(self, v, load=False):
    """
    Setter method for link_state, mapped from YANG variable /terminal_device/logical_channels/channel/state/link_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_state() directly.

    YANG Description: Link-state of the Ethernet protocol on the logical channel,
SONET / SDH framed signal, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_state must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__link_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_state(self):
    self.__link_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'UP': {}},), is_leaf=True, yang_name="link-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  admin_state = __builtin__.property(_get_admin_state)
  rate_class = __builtin__.property(_get_rate_class)
  trib_protocol = __builtin__.property(_get_trib_protocol)
  logical_channel_type = __builtin__.property(_get_logical_channel_type)
  loopback_mode = __builtin__.property(_get_loopback_mode)
  test_signal = __builtin__.property(_get_test_signal)
  link_state = __builtin__.property(_get_link_state)


  _pyangbind_elements = {'index': index, 'description': description, 'admin_state': admin_state, 'rate_class': rate_class, 'trib_protocol': trib_protocol, 'logical_channel_type': logical_channel_type, 'loopback_mode': loopback_mode, 'test_signal': test_signal, 'link_state': link_state, }


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for OTN protocol framing
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__tti_msg_transmit','__tti_msg_expected','__tti_msg_auto',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tti_msg_expected = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tti_msg_transmit = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'config']

  def _get_tti_msg_transmit(self):
    """
    Getter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_transmit (string)

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    return self.__tti_msg_transmit
      
  def _set_tti_msg_transmit(self, v, load=False):
    """
    Setter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_transmit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_transmit() directly.

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_transmit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__tti_msg_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_transmit(self):
    self.__tti_msg_transmit = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_tti_msg_expected(self):
    """
    Getter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_expected (string)

    YANG Description: Trail trace identifier (TTI) message expected
    """
    return self.__tti_msg_expected
      
  def _set_tti_msg_expected(self, v, load=False):
    """
    Setter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_expected (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_expected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_expected() directly.

    YANG Description: Trail trace identifier (TTI) message expected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_expected must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__tti_msg_expected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_expected(self):
    self.__tti_msg_expected = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_tti_msg_auto(self):
    """
    Getter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_auto (boolean)

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    return self.__tti_msg_auto
      
  def _set_tti_msg_auto(self, v, load=False):
    """
    Setter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config/tti_msg_auto (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_auto() directly.

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_auto must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)""",
        })

    self.__tti_msg_auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_auto(self):
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=True)

  tti_msg_transmit = __builtin__.property(_get_tti_msg_transmit, _set_tti_msg_transmit)
  tti_msg_expected = __builtin__.property(_get_tti_msg_expected, _set_tti_msg_expected)
  tti_msg_auto = __builtin__.property(_get_tti_msg_auto, _set_tti_msg_auto)


  _pyangbind_elements = {'tti_msg_transmit': tti_msg_transmit, 'tti_msg_expected': tti_msg_expected, 'tti_msg_auto': tti_msg_auto, }


class yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/pre-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'pre-fec-ber'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'pre-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/post-fec-ber. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'post-fec-ber'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'post-fec-ber']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/q-value. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'q-value'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'q-value']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state/esnr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'esnr'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state', u'esnr']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__tti_msg_transmit','__tti_msg_expected','__tti_msg_auto','__tti_msg_recv','__rdi_msg','__errored_seconds','__severely_errored_seconds','__unavailable_seconds','__code_violations','__fec_uncorrectable_words','__fec_corrected_bytes','__fec_corrected_bits','__background_block_errors','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__tti_msg_recv = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__tti_msg_transmit = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__tti_msg_expected = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__code_violations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__rdi_msg = YANGDynClass(base=unicode, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__background_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn', u'state']

  def _get_tti_msg_transmit(self):
    """
    Getter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_transmit (string)

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    return self.__tti_msg_transmit
      
  def _set_tti_msg_transmit(self, v, load=False):
    """
    Setter method for tti_msg_transmit, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_transmit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_transmit() directly.

    YANG Description: Trail trace identifier (TTI) message transmitted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_transmit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_transmit(self):
    self.__tti_msg_transmit = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-transmit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_tti_msg_expected(self):
    """
    Getter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_expected (string)

    YANG Description: Trail trace identifier (TTI) message expected
    """
    return self.__tti_msg_expected
      
  def _set_tti_msg_expected(self, v, load=False):
    """
    Setter method for tti_msg_expected, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_expected (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_expected is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_expected() directly.

    YANG Description: Trail trace identifier (TTI) message expected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_expected must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_expected = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_expected(self):
    self.__tti_msg_expected = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-expected", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_tti_msg_auto(self):
    """
    Getter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_auto (boolean)

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    return self.__tti_msg_auto
      
  def _set_tti_msg_auto(self, v, load=False):
    """
    Setter method for tti_msg_auto, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_auto (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_auto() directly.

    YANG Description: Trail trace identifier (TTI) transmit message automatically
created.  If true, then setting a custom transmit message
would be invalid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_auto must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)""",
        })

    self.__tti_msg_auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_auto(self):
    self.__tti_msg_auto = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="tti-msg-auto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='boolean', is_config=False)


  def _get_tti_msg_recv(self):
    """
    Getter method for tti_msg_recv, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_recv (string)

    YANG Description: Trail trace identifier (TTI) message received
    """
    return self.__tti_msg_recv
      
  def _set_tti_msg_recv(self, v, load=False):
    """
    Setter method for tti_msg_recv, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/tti_msg_recv (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tti_msg_recv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tti_msg_recv() directly.

    YANG Description: Trail trace identifier (TTI) message received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tti_msg_recv must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__tti_msg_recv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tti_msg_recv(self):
    self.__tti_msg_recv = YANGDynClass(base=unicode, is_leaf=True, yang_name="tti-msg-recv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_rdi_msg(self):
    """
    Getter method for rdi_msg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/rdi_msg (string)

    YANG Description: Remote defect indication (RDI) message received
    """
    return self.__rdi_msg
      
  def _set_rdi_msg(self, v, load=False):
    """
    Setter method for rdi_msg, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/rdi_msg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rdi_msg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rdi_msg() directly.

    YANG Description: Remote defect indication (RDI) message received
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rdi_msg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__rdi_msg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rdi_msg(self):
    self.__rdi_msg = YANGDynClass(base=unicode, is_leaf=True, yang_name="rdi-msg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_errored_seconds(self):
    """
    Getter method for errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_seconds (yang:counter64)

    YANG Description: The number of seconds that at least one errored blocks
occurs, at least one code violation occurs, loss of sync is
detected or loss of signal is detected
    """
    return self.__errored_seconds
      
  def _set_errored_seconds(self, v, load=False):
    """
    Setter method for errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/errored_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errored_seconds() directly.

    YANG Description: The number of seconds that at least one errored blocks
occurs, at least one code violation occurs, loss of sync is
detected or loss of signal is detected
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errored_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errored_seconds(self):
    self.__errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_severely_errored_seconds(self):
    """
    Getter method for severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/severely_errored_seconds (yang:counter64)

    YANG Description: The number of seconds that loss of frame is detected OR
the number of errored blocks, code violations, loss of sync
or loss of signal is detected exceeds a predefined
threshold
    """
    return self.__severely_errored_seconds
      
  def _set_severely_errored_seconds(self, v, load=False):
    """
    Setter method for severely_errored_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/severely_errored_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severely_errored_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severely_errored_seconds() directly.

    YANG Description: The number of seconds that loss of frame is detected OR
the number of errored blocks, code violations, loss of sync
or loss of signal is detected exceeds a predefined
threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """severely_errored_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__severely_errored_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_severely_errored_seconds(self):
    self.__severely_errored_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="severely-errored-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_unavailable_seconds(self):
    """
    Getter method for unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/unavailable_seconds (yang:counter64)

    YANG Description: The number of seconds during which the link is unavailable
    """
    return self.__unavailable_seconds
      
  def _set_unavailable_seconds(self, v, load=False):
    """
    Setter method for unavailable_seconds, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/unavailable_seconds (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unavailable_seconds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unavailable_seconds() directly.

    YANG Description: The number of seconds during which the link is unavailable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unavailable_seconds must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__unavailable_seconds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unavailable_seconds(self):
    self.__unavailable_seconds = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="unavailable-seconds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_code_violations(self):
    """
    Getter method for code_violations, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/code_violations (yang:counter64)

    YANG Description: For ethernet or fiberchannel links, the number of 8b/10b
coding violations. For SONET/SDH, the number of BIP (bit
interleaved parity) errors
    """
    return self.__code_violations
      
  def _set_code_violations(self, v, load=False):
    """
    Setter method for code_violations, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/code_violations (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_code_violations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_code_violations() directly.

    YANG Description: For ethernet or fiberchannel links, the number of 8b/10b
coding violations. For SONET/SDH, the number of BIP (bit
interleaved parity) errors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """code_violations must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__code_violations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_code_violations(self):
    self.__code_violations = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="code-violations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_uncorrectable_words(self):
    """
    Getter method for fec_uncorrectable_words, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_words (yang:counter64)

    YANG Description: The number words that were uncorrectable by the FEC
    """
    return self.__fec_uncorrectable_words
      
  def _set_fec_uncorrectable_words(self, v, load=False):
    """
    Setter method for fec_uncorrectable_words, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_uncorrectable_words (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_words is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_words() directly.

    YANG Description: The number words that were uncorrectable by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_words must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_words = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_words(self):
    self.__fec_uncorrectable_words = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-words", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bytes(self):
    """
    Getter method for fec_corrected_bytes, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bytes (yang:counter64)

    YANG Description: The number of bytes that were corrected by the FEC
    """
    return self.__fec_corrected_bytes
      
  def _set_fec_corrected_bytes(self, v, load=False):
    """
    Setter method for fec_corrected_bytes, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bytes (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bytes() directly.

    YANG Description: The number of bytes that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bytes must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bytes(self):
    self.__fec_corrected_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_fec_corrected_bits(self):
    """
    Getter method for fec_corrected_bits, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bits (yang:counter64)

    YANG Description: The number of bits that were corrected by the FEC
    """
    return self.__fec_corrected_bits
      
  def _set_fec_corrected_bits(self, v, load=False):
    """
    Setter method for fec_corrected_bits, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/fec_corrected_bits (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_corrected_bits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_corrected_bits() directly.

    YANG Description: The number of bits that were corrected by the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_corrected_bits must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_corrected_bits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_corrected_bits(self):
    self.__fec_corrected_bits = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-corrected-bits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_background_block_errors(self):
    """
    Getter method for background_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/background_block_errors (yang:counter64)

    YANG Description: The number of background block errors
    """
    return self.__background_block_errors
      
  def _set_background_block_errors(self, v, load=False):
    """
    Setter method for background_block_errors, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/background_block_errors (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_background_block_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_background_block_errors() directly.

    YANG Description: The number of background block errors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """background_block_errors must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__background_block_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_background_block_errors(self):
    self.__background_block_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="background-block-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=yc_pre_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=yc_post_fec_ber_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=yc_q_value_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=yc_esnr_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state_esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  tti_msg_transmit = __builtin__.property(_get_tti_msg_transmit)
  tti_msg_expected = __builtin__.property(_get_tti_msg_expected)
  tti_msg_auto = __builtin__.property(_get_tti_msg_auto)
  tti_msg_recv = __builtin__.property(_get_tti_msg_recv)
  rdi_msg = __builtin__.property(_get_rdi_msg)
  errored_seconds = __builtin__.property(_get_errored_seconds)
  severely_errored_seconds = __builtin__.property(_get_severely_errored_seconds)
  unavailable_seconds = __builtin__.property(_get_unavailable_seconds)
  code_violations = __builtin__.property(_get_code_violations)
  fec_uncorrectable_words = __builtin__.property(_get_fec_uncorrectable_words)
  fec_corrected_bytes = __builtin__.property(_get_fec_corrected_bytes)
  fec_corrected_bits = __builtin__.property(_get_fec_corrected_bits)
  background_block_errors = __builtin__.property(_get_background_block_errors)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = {'tti_msg_transmit': tti_msg_transmit, 'tti_msg_expected': tti_msg_expected, 'tti_msg_auto': tti_msg_auto, 'tti_msg_recv': tti_msg_recv, 'rdi_msg': rdi_msg, 'errored_seconds': errored_seconds, 'severely_errored_seconds': severely_errored_seconds, 'unavailable_seconds': unavailable_seconds, 'code_violations': code_violations, 'fec_uncorrectable_words': fec_uncorrectable_words, 'fec_corrected_bytes': fec_corrected_bytes, 'fec_corrected_bits': fec_corrected_bits, 'background_block_errors': background_block_errors, 'pre_fec_ber': pre_fec_ber, 'post_fec_ber': post_fec_ber, 'q_value': q_value, 'esnr': esnr, }


class yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/otn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'otn'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'otn']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config (container)

    YANG Description: Configuration data for OTN protocol framing
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/otn/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for OTN protocol framing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state (container)

    YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/otn/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for OTN protocol PMs, statistics,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_otn_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for Ethernet protocol framing
on logical channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__in_mac_control_frames','__in_mac_pause_frames','__in_oversize_frames','__in_jabber_frames','__in_fragment_frames','__in_8021q_frames','__in_crc_errors','__out_mac_control_frames','__out_mac_pause_frames','__out_8021q_frames',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet', u'state']

  def _get_in_mac_control_frames(self):
    """
    Getter method for in_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames received on the interface
    """
    return self.__in_mac_control_frames
      
  def _set_in_mac_control_frames(self, v, load=False):
    """
    Setter method for in_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_control_frames() directly.

    YANG Description: MAC layer control frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_control_frames(self):
    self.__in_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_mac_pause_frames(self):
    """
    Getter method for in_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    return self.__in_mac_pause_frames
      
  def _set_in_mac_pause_frames(self, v, load=False):
    """
    Setter method for in_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_mac_pause_frames(self):
    self.__in_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_oversize_frames(self):
    """
    Getter method for in_oversize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_oversize_frames (oc-yang:counter64)

    YANG Description: Number of oversize frames received on the interface
    """
    return self.__in_oversize_frames
      
  def _set_in_oversize_frames(self, v, load=False):
    """
    Setter method for in_oversize_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_oversize_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_oversize_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_oversize_frames() directly.

    YANG Description: Number of oversize frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_oversize_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_oversize_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_oversize_frames(self):
    self.__in_oversize_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-oversize-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_jabber_frames(self):
    """
    Getter method for in_jabber_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_jabber_frames (oc-yang:counter64)

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    return self.__in_jabber_frames
      
  def _set_in_jabber_frames(self, v, load=False):
    """
    Setter method for in_jabber_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_jabber_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_jabber_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_jabber_frames() directly.

    YANG Description: Number of jabber frames received on the
interface.  Jabber frames are typically defined as oversize
frames which also have a bad CRC.  Implementations may use
slightly different definitions of what constitutes a jabber
frame.  Often indicative of a NIC hardware problem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_jabber_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_jabber_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_jabber_frames(self):
    self.__in_jabber_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-jabber-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_fragment_frames(self):
    """
    Getter method for in_fragment_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_fragment_frames (oc-yang:counter64)

    YANG Description: Number of fragment frames received on the interface.
    """
    return self.__in_fragment_frames
      
  def _set_in_fragment_frames(self, v, load=False):
    """
    Setter method for in_fragment_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_fragment_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_fragment_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_fragment_frames() directly.

    YANG Description: Number of fragment frames received on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_fragment_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_fragment_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_fragment_frames(self):
    self.__in_fragment_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-fragment-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_8021q_frames(self):
    """
    Getter method for in_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    return self.__in_8021q_frames
      
  def _set_in_8021q_frames(self, v, load=False):
    """
    Setter method for in_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames received on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_8021q_frames(self):
    self.__in_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_in_crc_errors(self):
    """
    Getter method for in_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_crc_errors (oc-yang:counter64)

    YANG Description: Number of receive error events due to FCS/CRC check
failure
    """
    return self.__in_crc_errors
      
  def _set_in_crc_errors(self, v, load=False):
    """
    Setter method for in_crc_errors, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/in_crc_errors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_crc_errors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_crc_errors() directly.

    YANG Description: Number of receive error events due to FCS/CRC check
failure
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_crc_errors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__in_crc_errors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_crc_errors(self):
    self.__in_crc_errors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-crc-errors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_control_frames(self):
    """
    Getter method for out_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_control_frames (oc-yang:counter64)

    YANG Description: MAC layer control frames sent on the interface
    """
    return self.__out_mac_control_frames
      
  def _set_out_mac_control_frames(self, v, load=False):
    """
    Setter method for out_mac_control_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_control_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_control_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_control_frames() directly.

    YANG Description: MAC layer control frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_control_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_control_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_control_frames(self):
    self.__out_mac_control_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-control-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_mac_pause_frames(self):
    """
    Getter method for out_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_pause_frames (oc-yang:counter64)

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    return self.__out_mac_pause_frames
      
  def _set_out_mac_pause_frames(self, v, load=False):
    """
    Setter method for out_mac_pause_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_mac_pause_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_mac_pause_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_mac_pause_frames() directly.

    YANG Description: MAC layer PAUSE frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_mac_pause_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_mac_pause_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_mac_pause_frames(self):
    self.__out_mac_pause_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-mac-pause-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)


  def _get_out_8021q_frames(self):
    """
    Getter method for out_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_8021q_frames (oc-yang:counter64)

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    return self.__out_8021q_frames
      
  def _set_out_8021q_frames(self, v, load=False):
    """
    Setter method for out_8021q_frames, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state/out_8021q_frames (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_8021q_frames is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_8021q_frames() directly.

    YANG Description: Number of 802.1q tagged frames sent on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_8021q_frames must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__out_8021q_frames = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_8021q_frames(self):
    self.__out_8021q_frames = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-8021q-frames", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-yang:counter64', is_config=False)

  in_mac_control_frames = __builtin__.property(_get_in_mac_control_frames)
  in_mac_pause_frames = __builtin__.property(_get_in_mac_pause_frames)
  in_oversize_frames = __builtin__.property(_get_in_oversize_frames)
  in_jabber_frames = __builtin__.property(_get_in_jabber_frames)
  in_fragment_frames = __builtin__.property(_get_in_fragment_frames)
  in_8021q_frames = __builtin__.property(_get_in_8021q_frames)
  in_crc_errors = __builtin__.property(_get_in_crc_errors)
  out_mac_control_frames = __builtin__.property(_get_out_mac_control_frames)
  out_mac_pause_frames = __builtin__.property(_get_out_mac_pause_frames)
  out_8021q_frames = __builtin__.property(_get_out_8021q_frames)


  _pyangbind_elements = {'in_mac_control_frames': in_mac_control_frames, 'in_mac_pause_frames': in_mac_pause_frames, 'in_oversize_frames': in_oversize_frames, 'in_jabber_frames': in_jabber_frames, 'in_fragment_frames': in_fragment_frames, 'in_8021q_frames': in_8021q_frames, 'in_crc_errors': in_crc_errors, 'out_mac_control_frames': out_mac_control_frames, 'out_mac_pause_frames': out_mac_pause_frames, 'out_8021q_frames': out_8021q_frames, }


class yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for data related to Ethernet framing
for the logical channel
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state',)

  _yang_name = 'ethernet'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ethernet']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state (container)

    YANG Description: Operational state data for Ethernet protocol framing
on logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for Ethernet protocol framing
on logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'state': state, }


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the signal source for the
logical channel
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__transceiver','__physical_channel',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__physical_channel = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ingress', u'config']

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/transceiver (leafref)

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/transceiver (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_physical_channel(self):
    """
    Getter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/physical_channel (leafref)

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    return self.__physical_channel
      
  def _set_physical_channel(self, v, load=False):
    """
    Setter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config/physical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channel() directly.

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__physical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channel(self):
    self.__physical_channel = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

  transceiver = __builtin__.property(_get_transceiver, _set_transceiver)
  physical_channel = __builtin__.property(_get_physical_channel, _set_physical_channel)


  _pyangbind_elements = {'transceiver': transceiver, 'physical_channel': physical_channel, }


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the signal source for the
logical channel
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__transceiver','__physical_channel',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__physical_channel = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ingress', u'state']

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/transceiver (leafref)

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/transceiver (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.

    YANG Description: Reference to the transceiver carrying the input signal
for the logical channel.  If specific physical channels
are mapped to the logical channel (as opposed to all
physical channels carried by the transceiver), they can be
specified in the list of physical channel references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=unicode, is_leaf=True, yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_physical_channel(self):
    """
    Getter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/physical_channel (leafref)

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    return self.__physical_channel
      
  def _set_physical_channel(self, v, load=False):
    """
    Setter method for physical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state/physical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_channel() directly.

    YANG Description: This list should be populated with references
to the client physical channels that feed this logical
channel from the transceiver specified in the 'transceiver'
leaf, which must be specified.  If this leaf-list is empty,
all physical channels in the transceiver are assumed to be
mapped to the logical channel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__physical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_channel(self):
    self.__physical_channel = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="physical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

  transceiver = __builtin__.property(_get_transceiver)
  physical_channel = __builtin__.property(_get_physical_channel)


  _pyangbind_elements = {'transceiver': transceiver, 'physical_channel': physical_channel, }


class yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/ingress. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver or individual physical channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'ingress'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'ingress']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config (container)

    YANG Description: Configuration data for the signal source for the
logical channel
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the signal source for the
logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state (container)

    YANG Description: Operational state data for the signal source for the
logical channel
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/ingress/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the signal source for the
logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for tributary assignments
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__description','__assignment_type','__logical_channel','__optical_channel','__allocation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    self.__logical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    self.__optical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments', u'assignment', u'config']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/index (uint32)

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/description (string)

    YANG Description: Name assigned to the logical client channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Name assigned to the logical client channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=True)


  def _get_assignment_type(self):
    """
    Getter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/assignment_type (enumeration)

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    return self.__assignment_type
      
  def _set_assignment_type(self, v, load=False):
    """
    Setter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/assignment_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment_type() directly.

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)""",
        })

    self.__assignment_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment_type(self):
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=True)


  def _get_logical_channel(self):
    """
    Getter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/logical_channel (leafref)

    YANG Description: Reference to another stage of logical channel elements.
    """
    return self.__logical_channel
      
  def _set_logical_channel(self, v, load=False):
    """
    Setter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/logical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel() directly.

    YANG Description: Reference to another stage of logical channel elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__logical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel(self):
    self.__logical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/optical_channel (leafref)

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/optical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_allocation(self):
    """
    Getter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/allocation (decimal64)

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps
    """
    return self.__allocation
      
  def _set_allocation(self, v, load=False):
    """
    Setter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config/allocation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocation() directly.

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)""",
        })

    self.__allocation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocation(self):
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  description = __builtin__.property(_get_description, _set_description)
  assignment_type = __builtin__.property(_get_assignment_type, _set_assignment_type)
  logical_channel = __builtin__.property(_get_logical_channel, _set_logical_channel)
  optical_channel = __builtin__.property(_get_optical_channel, _set_optical_channel)
  allocation = __builtin__.property(_get_allocation, _set_allocation)


  _pyangbind_elements = {'index': index, 'description': description, 'assignment_type': assignment_type, 'logical_channel': logical_channel, 'optical_channel': optical_channel, 'allocation': allocation, }


class yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for tributary assignments
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__description','__assignment_type','__logical_channel','__optical_channel','__allocation',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    self.__logical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__optical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments', u'assignment', u'state']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/index (uint32)

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of the current logical client channel to tributary
mapping
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/description (string)

    YANG Description: Name assigned to the logical client channel
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Name assigned to the logical client channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_assignment_type(self):
    """
    Getter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/assignment_type (enumeration)

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    return self.__assignment_type
      
  def _set_assignment_type(self, v, load=False):
    """
    Setter method for assignment_type, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/assignment_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment_type() directly.

    YANG Description: Each logical channel element may be assigned to subsequent
stages of logical elements to implement further grooming, or
can be assigned to a line-side optical channel for
transmission.  Each assignment also has an associated
bandwidth allocation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment_type must be of a type compatible with enumeration""",
          'defined-type': "openconfig-terminal-device:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)""",
        })

    self.__assignment_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment_type(self):
    self.__assignment_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LOGICAL_CHANNEL': {}, u'OPTICAL_CHANNEL': {}},), is_leaf=True, yang_name="assignment-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='enumeration', is_config=False)


  def _get_logical_channel(self):
    """
    Getter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/logical_channel (leafref)

    YANG Description: Reference to another stage of logical channel elements.
    """
    return self.__logical_channel
      
  def _set_logical_channel(self, v, load=False):
    """
    Setter method for logical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/logical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel() directly.

    YANG Description: Reference to another stage of logical channel elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel(self):
    self.__logical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="logical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/optical_channel (leafref)

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/optical_channel (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.

    YANG Description: Reference to the line-side optical channel that should
carry the current logical channel element.  Use this
reference to exit the logical element stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=unicode, is_leaf=True, yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_allocation(self):
    """
    Getter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/allocation (decimal64)

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps
    """
    return self.__allocation
      
  def _set_allocation(self, v, load=False):
    """
    Setter method for allocation, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state/allocation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocation() directly.

    YANG Description: Allocation of the logical client channel to the tributary
or sub-channel, expressed in Gbps
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__allocation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocation(self):
    self.__allocation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=3), is_leaf=True, yang_name="allocation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)

  index = __builtin__.property(_get_index)
  description = __builtin__.property(_get_description)
  assignment_type = __builtin__.property(_get_assignment_type)
  logical_channel = __builtin__.property(_get_logical_channel)
  optical_channel = __builtin__.property(_get_optical_channel)
  allocation = __builtin__.property(_get_allocation)


  _pyangbind_elements = {'index': index, 'description': description, 'assignment_type': assignment_type, 'logical_channel': logical_channel, 'optical_channel': optical_channel, 'allocation': allocation, }


class yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments/assignment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__config','__state',)

  _yang_name = 'assignment'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments', u'assignment']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/index (leafref)

    YANG Description: Reference to the index for the current tributary
assignment
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index for the current tributary
assignment
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config (container)

    YANG Description: Configuration data for tributary assignments
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state (container)

    YANG Description: Operational state data for tributary assignments
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'index': index, 'config': config, 'state': state, }


class yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel/logical-channel-assignments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for tributary assignments
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__assignment',)

  _yang_name = 'logical-channel-assignments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__assignment = YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel', u'logical-channel-assignments']

  def _get_assignment(self):
    """
    Getter method for assignment, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment (list)

    YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
    """
    return self.__assignment
      
  def _set_assignment(self, v, load=False):
    """
    Setter method for assignment, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments/assignment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assignment() directly.

    YANG Description: Logical channel elements may be assigned directly to
optical channels for line-side transmission, or can be
further groomed into additional stages of logical channel
elements.  The grooming can multiplex (i.e., split the
current element into multiple elements in the subsequent
stage) or de-multiplex (i.e., combine the current element
with other elements into the same element in the subsequent
stage) logical elements in each stage.

Note that to support the ability to groom the logical
elements, the list of logical channel elements should be
populated with an entry for the logical elements at
each stage, starting with the initial assignment from the
respective client physical port.

Each logical element assignment consists of a pointer to
an element in the next stage, or to an optical channel,
along with a bandwidth allocation for the corresponding
assignment (e.g., to split or combine signal).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assignment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assignment(self):
    self.__assignment = YANGDynClass(base=YANGListType("index",yc_assignment_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments_assignment, yang_name="assignment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  assignment = __builtin__.property(_get_assignment, _set_assignment)


  _pyangbind_elements = {'assignment': assignment, }


class yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels/channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of logical channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__index','__config','__state','__otn','__ethernet','__ingress','__logical_channel_assignments',)

  _yang_name = 'channel'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    self.__ingress = YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__otn = YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__logical_channel_assignments = YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels', u'channel']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/index (leafref)

    YANG Description: Reference to the index of the logical channel
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /terminal_device/logical_channels/channel/index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Reference to the index of the logical channel
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=unicode, is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/config (container)

    YANG Description: Configuration data for logical channels
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /terminal_device/logical_channels/channel/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_terminal_device__terminal_device_logical_channels_channel_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/state (container)

    YANG Description: Operational state data for logical channels
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/logical_channels/channel/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_logical_channels_channel_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_otn(self):
    """
    Getter method for otn, mapped from YANG variable /terminal_device/logical_channels/channel/otn (container)

    YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
    """
    return self.__otn
      
  def _set_otn(self, v, load=False):
    """
    Setter method for otn, mapped from YANG variable /terminal_device/logical_channels/channel/otn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_otn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_otn() directly.

    YANG Description: Top level container for OTU configuration when logical
channel framing is using an OTU protocol, e.g., OTU1, OTU3,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """otn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__otn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_otn(self):
    self.__otn = YANGDynClass(base=yc_otn_openconfig_terminal_device__terminal_device_logical_channels_channel_otn, is_container='container', yang_name="otn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_ethernet(self):
    """
    Getter method for ethernet, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet (container)

    YANG Description: Top level container for data related to Ethernet framing
for the logical channel
    """
    return self.__ethernet
      
  def _set_ethernet(self, v, load=False):
    """
    Setter method for ethernet, mapped from YANG variable /terminal_device/logical_channels/channel/ethernet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet() directly.

    YANG Description: Top level container for data related to Ethernet framing
for the logical channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__ethernet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet(self):
    self.__ethernet = YANGDynClass(base=yc_ethernet_openconfig_terminal_device__terminal_device_logical_channels_channel_ethernet, is_container='container', yang_name="ethernet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_ingress(self):
    """
    Getter method for ingress, mapped from YANG variable /terminal_device/logical_channels/channel/ingress (container)

    YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver or individual physical channels
    """
    return self.__ingress
      
  def _set_ingress(self, v, load=False):
    """
    Setter method for ingress, mapped from YANG variable /terminal_device/logical_channels/channel/ingress (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingress() directly.

    YANG Description: Top-level container for specifying references to the
source of signal for the logical channel, either a
transceiver or individual physical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingress must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__ingress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingress(self):
    self.__ingress = YANGDynClass(base=yc_ingress_openconfig_terminal_device__terminal_device_logical_channels_channel_ingress, is_container='container', yang_name="ingress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_logical_channel_assignments(self):
    """
    Getter method for logical_channel_assignments, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments (container)

    YANG Description: Enclosing container for tributary assignments
    """
    return self.__logical_channel_assignments
      
  def _set_logical_channel_assignments(self, v, load=False):
    """
    Setter method for logical_channel_assignments, mapped from YANG variable /terminal_device/logical_channels/channel/logical_channel_assignments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignments() directly.

    YANG Description: Enclosing container for tributary assignments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__logical_channel_assignments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignments(self):
    self.__logical_channel_assignments = YANGDynClass(base=yc_logical_channel_assignments_openconfig_terminal_device__terminal_device_logical_channels_channel_logical_channel_assignments, is_container='container', yang_name="logical-channel-assignments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  index = __builtin__.property(_get_index, _set_index)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  otn = __builtin__.property(_get_otn, _set_otn)
  ethernet = __builtin__.property(_get_ethernet, _set_ethernet)
  ingress = __builtin__.property(_get_ingress, _set_ingress)
  logical_channel_assignments = __builtin__.property(_get_logical_channel_assignments, _set_logical_channel_assignments)


  _pyangbind_elements = {'index': index, 'config': config, 'state': state, 'otn': otn, 'ethernet': ethernet, 'ingress': ingress, 'logical_channel_assignments': logical_channel_assignments, }


class yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/logical-channels. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container the list of logical channels
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__channel',)

  _yang_name = 'logical-channels'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'logical-channels']

  def _get_channel(self):
    """
    Getter method for channel, mapped from YANG variable /terminal_device/logical_channels/channel (list)

    YANG Description: List of logical channels
    """
    return self.__channel
      
  def _set_channel(self, v, load=False):
    """
    Setter method for channel, mapped from YANG variable /terminal_device/logical_channels/channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel() directly.

    YANG Description: List of logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel(self):
    self.__channel = YANGDynClass(base=YANGListType("index",yc_channel_openconfig_terminal_device__terminal_device_logical_channels_channel, yang_name="channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  channel = __builtin__.property(_get_channel, _set_channel)


  _pyangbind_elements = {'channel': channel, }


class yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes/mode/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the platform-defined
operational mode
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mode_id','__description','__vendor_id',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vendor_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    self.__mode_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'operational-modes', u'mode', u'state']

  def _get_mode_id(self):
    """
    Getter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/mode_id (uint16)

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    return self.__mode_id
      
  def _set_mode_id(self, v, load=False):
    """
    Setter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/mode_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_id() directly.

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__mode_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_id(self):
    self.__mode_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /terminal_device/operational_modes/mode/state/description (string)

    YANG Description: Vendor-supplied textual description of the characteristics
of this operational mode to enable operators to select the
appropriate mode for the application.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /terminal_device/operational_modes/mode/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Vendor-supplied textual description of the characteristics
of this operational mode to enable operators to select the
appropriate mode for the application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)


  def _get_vendor_id(self):
    """
    Getter method for vendor_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/vendor_id (string)

    YANG Description: Identifier to represent the vendor / supplier of the
platform and the associated operational mode information
    """
    return self.__vendor_id
      
  def _set_vendor_id(self, v, load=False):
    """
    Setter method for vendor_id, mapped from YANG variable /terminal_device/operational_modes/mode/state/vendor_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_id() directly.

    YANG Description: Identifier to represent the vendor / supplier of the
platform and the associated operational mode information
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)""",
        })

    self.__vendor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_id(self):
    self.__vendor_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='string', is_config=False)

  mode_id = __builtin__.property(_get_mode_id)
  description = __builtin__.property(_get_description)
  vendor_id = __builtin__.property(_get_vendor_id)


  _pyangbind_elements = {'mode_id': mode_id, 'description': description, 'vendor_id': vendor_id, }


class yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes/mode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mode_id','__state',)

  _yang_name = 'mode'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__mode_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'operational-modes', u'mode']

  def _get_mode_id(self):
    """
    Getter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/mode_id (leafref)

    YANG Description: Reference to mode-id
    """
    return self.__mode_id
      
  def _set_mode_id(self, v, load=False):
    """
    Setter method for mode_id, mapped from YANG variable /terminal_device/operational_modes/mode/mode_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_id() directly.

    YANG Description: Reference to mode-id
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__mode_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_id(self):
    self.__mode_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="mode-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /terminal_device/operational_modes/mode/state (container)

    YANG Description: Operational state data for the platform-defined
operational mode
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /terminal_device/operational_modes/mode/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the platform-defined
operational mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_terminal_device__terminal_device_operational_modes_mode_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  mode_id = __builtin__.property(_get_mode_id)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = {'mode_id': mode_id, 'state': state, }


class yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device/operational-modes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of operational modes
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mode',)

  _yang_name = 'operational-modes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device', u'operational-modes']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /terminal_device/operational_modes/mode (list)

    YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /terminal_device/operational_modes/mode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: List of operational modes supported by the platform.
The operational mode provides a platform-defined summary
of information such as symbol rate, modulation, pulse
shaping, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=YANGListType("mode_id",yc_mode_openconfig_terminal_device__terminal_device_operational_modes_mode, yang_name="mode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode-id', extensions=None), is_container='list', yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='list', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)


  _pyangbind_elements = {'mode': mode, }


class yc_terminal_device_openconfig_terminal_device__terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for the terminal device
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__logical_channels','__operational_modes',)

  _yang_name = 'terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operational_modes = YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    self.__logical_channels = YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'terminal-device']

  def _get_logical_channels(self):
    """
    Getter method for logical_channels, mapped from YANG variable /terminal_device/logical_channels (container)

    YANG Description: Enclosing container the list of logical channels
    """
    return self.__logical_channels
      
  def _set_logical_channels(self, v, load=False):
    """
    Setter method for logical_channels, mapped from YANG variable /terminal_device/logical_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channels() directly.

    YANG Description: Enclosing container the list of logical channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__logical_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channels(self):
    self.__logical_channels = YANGDynClass(base=yc_logical_channels_openconfig_terminal_device__terminal_device_logical_channels, is_container='container', yang_name="logical-channels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)


  def _get_operational_modes(self):
    """
    Getter method for operational_modes, mapped from YANG variable /terminal_device/operational_modes (container)

    YANG Description: Enclosing container for list of operational modes
    """
    return self.__operational_modes
      
  def _set_operational_modes(self, v, load=False):
    """
    Setter method for operational_modes, mapped from YANG variable /terminal_device/operational_modes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_modes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_modes() directly.

    YANG Description: Enclosing container for list of operational modes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_modes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__operational_modes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_modes(self):
    self.__operational_modes = YANGDynClass(base=yc_operational_modes_openconfig_terminal_device__terminal_device_operational_modes, is_container='container', yang_name="operational-modes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  logical_channels = __builtin__.property(_get_logical_channels, _set_logical_channels)
  operational_modes = __builtin__.property(_get_operational_modes, _set_operational_modes)


  _pyangbind_elements = {'logical_channels': logical_channels, 'operational_modes': operational_modes, }


class openconfig_terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /openconfig-terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a terminal optics device model for
managing the terminal systems (client and line side) in a
DWDM transport network.

Elements of the model:

physical port: corresponds to a physical, pluggable client
port on the terminal device. Examples includes 10G, 40G, 100G
(e.g., 10x10G, 4x25G or 1x100G) and 400G/1T in the future.
Physical client ports will have associated operational state or
PMs.

physical channel: a physical lane or channel in the
physical client port.  Each physical client port has 1 or more
channels. An example is 100GBASE-LR4 client physical port having
4x25G channels. Channels have their own optical PMs and can be
monitored independently within a client physical port (e.g.,
channel power).  Physical client channels are defined in the
model as part of a physical client port, and are modeled
primarily for reading their PMs.

logical channel: a logical grouping of logical grooming elements
that may be assigned to subsequent grooming stages for
multiplexing / de-multiplexing, or to an optical channel for
line side transmission.  The logical channels can represent, for
example, an ODU/OTU logical packing of the client
data onto the line side.  Tributaries are similarly logical
groupings of demand that can be represented in this structure and
assigned to an optical channel.  Note that different types of
logical channels may be present, each with their corresponding
PMs.

optical channel:  corresponds to an optical carrier and is
assigned a wavelength/frequency.  Optical channels have PMs
such as power, BER, and operational mode.

Directionality:

To maintain simplicity in the model, the configuration is
described from client-to-line direction.  The assumption is that
equivalent reverse configuration is implicit, resulting in
the same line-to-client configuration.

Physical layout:

The model does not assume a particular physical layout of client
and line ports on the terminal device (e.g., such as number of
ports per linecard, separate linecards for client and line ports,
etc.).
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__terminal_device',)

  _yang_name = 'openconfig-terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__terminal_device = YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_terminal_device(self):
    """
    Getter method for terminal_device, mapped from YANG variable /terminal_device (container)

    YANG Description: Top-level container for the terminal device
    """
    return self.__terminal_device
      
  def _set_terminal_device(self, v, load=False):
    """
    Setter method for terminal_device, mapped from YANG variable /terminal_device (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminal_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminal_device() directly.

    YANG Description: Top-level container for the terminal device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminal_device must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__terminal_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminal_device(self):
    self.__terminal_device = YANGDynClass(base=yc_terminal_device_openconfig_terminal_device__terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  terminal_device = __builtin__.property(_get_terminal_device, _set_terminal_device)


  _pyangbind_elements = {'terminal_device': terminal_device, }


