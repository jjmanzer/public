
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for an automatic protection
switch module
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__revertive','__primary_switch_threshold','__primary_switch_hysteresis','__secondary_switch_threshold','__secondary_switch_hysteresis',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__secondary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)

    YANG Description: Revertive behavior of the module.
If True, then automatically revert after protection switch
once the fault is restored.
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: Revertive behavior of the module.
If True, then automatically revert after protection switch
once the fault is restored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_primary_switch_threshold(self):
    """
    Getter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    return self.__primary_switch_threshold
      
  def _set_primary_switch_threshold(self, v, load=False):
    """
    Setter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_threshold() directly.

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_threshold(self):
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_primary_switch_hysteresis(self):
    """
    Getter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)

    YANG Description: The delta in 0.01 dB between the primary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    return self.__primary_switch_hysteresis
      
  def _set_primary_switch_hysteresis(self, v, load=False):
    """
    Setter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_hysteresis() directly.

    YANG Description: The delta in 0.01 dB between the primary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_hysteresis(self):
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_secondary_switch_threshold(self):
    """
    Getter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    return self.__secondary_switch_threshold
      
  def _set_secondary_switch_threshold(self, v, load=False):
    """
    Setter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_threshold() directly.

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__secondary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_threshold(self):
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_secondary_switch_hysteresis(self):
    """
    Getter method for secondary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_hysteresis (decimal64)

    YANG Description: The delta in 0.01 dB between the secondary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    return self.__secondary_switch_hysteresis
      
  def _set_secondary_switch_hysteresis(self, v, load=False):
    """
    Setter method for secondary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_hysteresis() directly.

    YANG Description: The delta in 0.01 dB between the secondary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__secondary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_hysteresis(self):
    self.__secondary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  primary_switch_threshold = __builtin__.property(_get_primary_switch_threshold, _set_primary_switch_threshold)
  primary_switch_hysteresis = __builtin__.property(_get_primary_switch_hysteresis, _set_primary_switch_hysteresis)
  secondary_switch_threshold = __builtin__.property(_get_secondary_switch_threshold, _set_secondary_switch_threshold)
  secondary_switch_hysteresis = __builtin__.property(_get_secondary_switch_hysteresis, _set_secondary_switch_hysteresis)


  _pyangbind_elements = {'name': name, 'revertive': revertive, 'primary_switch_threshold': primary_switch_threshold, 'primary_switch_hysteresis': primary_switch_hysteresis, 'secondary_switch_threshold': secondary_switch_threshold, 'secondary_switch_hysteresis': secondary_switch_hysteresis, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for an automatic protection
switch module
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__revertive','__primary_switch_threshold','__primary_switch_hysteresis','__secondary_switch_threshold','__secondary_switch_hysteresis','__active_path',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)
    self.__active_path = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-line-protect:SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'oc-line-protect:PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__secondary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/state/name (leafref)

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=False)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/state/revertive (boolean)

    YANG Description: Revertive behavior of the module.
If True, then automatically revert after protection switch
once the fault is restored.
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/state/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: Revertive behavior of the module.
If True, then automatically revert after protection switch
once the fault is restored.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_primary_switch_threshold(self):
    """
    Getter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_threshold (decimal64)

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    return self.__primary_switch_threshold
      
  def _set_primary_switch_threshold(self, v, load=False):
    """
    Setter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_threshold() directly.

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__primary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_threshold(self):
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_primary_switch_hysteresis(self):
    """
    Getter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_hysteresis (decimal64)

    YANG Description: The delta in 0.01 dB between the primary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    return self.__primary_switch_hysteresis
      
  def _set_primary_switch_hysteresis(self, v, load=False):
    """
    Setter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/state/primary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_hysteresis() directly.

    YANG Description: The delta in 0.01 dB between the primary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__primary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_hysteresis(self):
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_secondary_switch_threshold(self):
    """
    Getter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/secondary_switch_threshold (decimal64)

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    return self.__secondary_switch_threshold
      
  def _set_secondary_switch_threshold(self, v, load=False):
    """
    Setter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/state/secondary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_threshold() directly.

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__secondary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_threshold(self):
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_secondary_switch_hysteresis(self):
    """
    Getter method for secondary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/state/secondary_switch_hysteresis (decimal64)

    YANG Description: The delta in 0.01 dB between the secondary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    return self.__secondary_switch_hysteresis
      
  def _set_secondary_switch_hysteresis(self, v, load=False):
    """
    Setter method for secondary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/state/secondary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_hysteresis() directly.

    YANG Description: The delta in 0.01 dB between the secondary-switch-threshold
and the signal received before initiating a reversion in
order to prevent toggling between ports when an input
signal is very close to threshold. If the hardware supports
only one switch hysteresis for primary and secondary ports
then it is recommended to set both primary-switch-threshold
and secondary-switch-threshold to the same value to be
explicit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__secondary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_hysteresis(self):
    self.__secondary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_active_path(self):
    """
    Getter method for active_path, mapped from YANG variable /aps/aps_modules/aps_module/state/active_path (identityref)

    YANG Description: Indicates which line path on the automatic protection switch
is currently the active path connected to the common port
    """
    return self.__active_path
      
  def _set_active_path(self, v, load=False):
    """
    Setter method for active_path, mapped from YANG variable /aps/aps_modules/aps_module/state/active_path (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_path() directly.

    YANG Description: Indicates which line path on the automatic protection switch
is currently the active path connected to the common port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-line-protect:SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'oc-line-protect:PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_path must be of a type compatible with identityref""",
          'defined-type': "openconfig-transport-line-protection:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-line-protect:SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'oc-line-protect:PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)""",
        })

    self.__active_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_path(self):
    self.__active_path = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-line-protect:SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'oc-line-protect:PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'PRIMARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}, u'SECONDARY': {'@namespace': u'http://openconfig.net/yang/optical-transport-line-protection', '@module': u'openconfig-transport-line-protection'}},), is_leaf=True, yang_name="active-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='identityref', is_config=False)

  name = __builtin__.property(_get_name)
  revertive = __builtin__.property(_get_revertive)
  primary_switch_threshold = __builtin__.property(_get_primary_switch_threshold)
  primary_switch_hysteresis = __builtin__.property(_get_primary_switch_hysteresis)
  secondary_switch_threshold = __builtin__.property(_get_secondary_switch_threshold)
  secondary_switch_hysteresis = __builtin__.property(_get_secondary_switch_hysteresis)
  active_path = __builtin__.property(_get_active_path)


  _pyangbind_elements = {'name': name, 'revertive': revertive, 'primary_switch_threshold': primary_switch_threshold, 'primary_switch_hysteresis': primary_switch_hysteresis, 'secondary_switch_threshold': secondary_switch_threshold, 'secondary_switch_hysteresis': secondary_switch_hysteresis, 'active_path': active_path, }


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line primary input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__enabled','__target_attenuation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-in', u'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = {'enabled': enabled, 'target_attenuation': target_attenuation, }


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-in', u'state', u'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line primary input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__enabled','__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-in', u'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power (container)

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = {'enabled': enabled, 'target_attenuation': target_attenuation, 'attenuation': attenuation, 'optical_power': optical_power, }


class yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-in. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line primary
input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'line-primary-in'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-in']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config (container)

    YANG Description: Configuration data for the line primary input port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line primary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state (container)

    YANG Description: State data for the line primary input port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line primary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line primary output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__target_attenuation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-out', u'config']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = {'target_attenuation': target_attenuation, }


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-out', u'state', u'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line primary output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-out', u'state']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power (container)

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = {'target_attenuation': target_attenuation, 'attenuation': attenuation, 'optical_power': optical_power, }


class yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-primary-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line primary
output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'line-primary-out'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-primary-out']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config (container)

    YANG Description: Configuration data for the line primary output port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line primary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state (container)

    YANG Description: State data for the line primary output port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line primary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line secondary input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__enabled','__target_attenuation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-in', u'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = {'enabled': enabled, 'target_attenuation': target_attenuation, }


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-in', u'state', u'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line secondary input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__enabled','__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-in', u'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power (container)

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = {'enabled': enabled, 'target_attenuation': target_attenuation, 'attenuation': attenuation, 'optical_power': optical_power, }


class yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-in. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line secondary
input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'line-secondary-in'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-in']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config (container)

    YANG Description: Configuration data for the line secondary input port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line secondary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state (container)

    YANG Description: State data for the line secondary input port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line secondary input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line secondary output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__target_attenuation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-out', u'config']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = {'target_attenuation': target_attenuation, }


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-out', u'state', u'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line secondary output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-out', u'state']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power (container)

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = {'target_attenuation': target_attenuation, 'attenuation': attenuation, 'optical_power': optical_power, }


class yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/line-secondary-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line secondary
output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'line-secondary-out'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'line-secondary-out']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config (container)

    YANG Description: Configuration data for the line secondary output port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line secondary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state (container)

    YANG Description: State data for the line secondary output port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line secondary output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line common input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__enabled','__target_attenuation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-in', u'config']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = {'enabled': enabled, 'target_attenuation': target_attenuation, }


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-in', u'state', u'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line common input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__enabled','__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-in', u'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/enabled (boolean)

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf contains the configured, desired state of the
port. Disabling the port turns off alarm reporting for
the port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=False)


  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power (container)

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical input power of this port in units of
0.01dBm. Optical input power represents the signal
traversing from an external destination into the module.
The power is measured before any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = {'enabled': enabled, 'target_attenuation': target_attenuation, 'attenuation': attenuation, 'optical_power': optical_power, }


class yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-in. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line common
input port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'common-in'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-in']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config (container)

    YANG Description: Configuration data for the line common input port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line common input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state (container)

    YANG Description: State data for the line common input port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line common input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the line common output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__target_attenuation',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-output', u'config']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)

  target_attenuation = __builtin__.property(_get_target_attenuation, _set_target_attenuation)


  _pyangbind_elements = {'target_attenuation': target_attenuation, }


class yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output/state/optical-power. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__instant','__avg','__min_','__max_',)

  _yang_name = 'optical-power'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-output', u'state', u'optical-power']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)

  instant = __builtin__.property(_get_instant)
  avg = __builtin__.property(_get_avg)
  min_ = __builtin__.property(_get_min_)
  max_ = __builtin__.property(_get_max_)


  _pyangbind_elements = {'instant': instant, 'avg': avg, 'min_': min_, 'max_': max_, }


class yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data for the line common output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__target_attenuation','__attenuation','__optical_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-output', u'state']

  def _get_target_attenuation(self):
    """
    Getter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/target_attenuation (decimal64)

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__target_attenuation
      
  def _set_target_attenuation(self, v, load=False):
    """
    Setter method for target_attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/target_attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_attenuation() directly.

    YANG Description: Target attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__target_attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_attenuation(self):
    self.__target_attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_attenuation(self):
    """
    Getter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/attenuation (decimal64)

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    return self.__attenuation
      
  def _set_attenuation(self, v, load=False):
    """
    Setter method for attenuation, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/attenuation (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attenuation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attenuation() directly.

    YANG Description: The attenuation of the variable optical attenuator
associated with the port in increments of 0.01 dB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attenuation must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)""",
        })

    self.__attenuation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attenuation(self):
    self.__attenuation = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="attenuation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=False)


  def _get_optical_power(self):
    """
    Getter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power (container)

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    return self.__optical_power
      
  def _set_optical_power(self, v, load=False):
    """
    Setter method for optical_power, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state/optical_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_power() directly.

    YANG Description: The optical output power of this port in units of
0.01dBm. Optical output power represents the signal
traversing from the module to an external destination. The
power is measured after any attenuation. If avg/min/max
statistics are not supported, the target is expected to
just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)""",
        })

    self.__optical_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_power(self):
    self.__optical_power = YANGDynClass(base=yc_optical_power_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state_optical_power, is_container='container', yang_name="optical-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=False)

  target_attenuation = __builtin__.property(_get_target_attenuation)
  attenuation = __builtin__.property(_get_attenuation)
  optical_power = __builtin__.property(_get_optical_power)


  _pyangbind_elements = {'target_attenuation': target_attenuation, 'attenuation': attenuation, 'optical_power': optical_power, }


class yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports/common-output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for information related to the line common
output port
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'common-output'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports', u'common-output']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config (container)

    YANG Description: Configuration data for the line common output port
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the line common output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state (container)

    YANG Description: State data for the line common output port
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State data for the line common output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level grouping for automatic protection switch ports
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__line_primary_in','__line_primary_out','__line_secondary_in','__line_secondary_out','__common_in','__common_output',)

  _yang_name = 'ports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__line_primary_in = YANGDynClass(base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__common_output = YANGDynClass(base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__line_secondary_in = YANGDynClass(base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__line_secondary_out = YANGDynClass(base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__common_in = YANGDynClass(base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__line_primary_out = YANGDynClass(base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module', u'ports']

  def _get_line_primary_in(self):
    """
    Getter method for line_primary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in (container)

    YANG Description: Container for information related to the line primary
input port
    """
    return self.__line_primary_in
      
  def _set_line_primary_in(self, v, load=False):
    """
    Setter method for line_primary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_in (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_primary_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_primary_in() directly.

    YANG Description: Container for information related to the line primary
input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_primary_in must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_primary_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_primary_in(self):
    self.__line_primary_in = YANGDynClass(base=yc_line_primary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_in, is_container='container', yang_name="line-primary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_line_primary_out(self):
    """
    Getter method for line_primary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out (container)

    YANG Description: Container for information related to the line primary
output port
    """
    return self.__line_primary_out
      
  def _set_line_primary_out(self, v, load=False):
    """
    Setter method for line_primary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_primary_out (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_primary_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_primary_out() directly.

    YANG Description: Container for information related to the line primary
output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_primary_out must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_primary_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_primary_out(self):
    self.__line_primary_out = YANGDynClass(base=yc_line_primary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_primary_out, is_container='container', yang_name="line-primary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_line_secondary_in(self):
    """
    Getter method for line_secondary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in (container)

    YANG Description: Container for information related to the line secondary
input port
    """
    return self.__line_secondary_in
      
  def _set_line_secondary_in(self, v, load=False):
    """
    Setter method for line_secondary_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_in (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_secondary_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_secondary_in() directly.

    YANG Description: Container for information related to the line secondary
input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_secondary_in must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_secondary_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_secondary_in(self):
    self.__line_secondary_in = YANGDynClass(base=yc_line_secondary_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_in, is_container='container', yang_name="line-secondary-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_line_secondary_out(self):
    """
    Getter method for line_secondary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out (container)

    YANG Description: Container for information related to the line secondary
output port
    """
    return self.__line_secondary_out
      
  def _set_line_secondary_out(self, v, load=False):
    """
    Setter method for line_secondary_out, mapped from YANG variable /aps/aps_modules/aps_module/ports/line_secondary_out (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_secondary_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_secondary_out() directly.

    YANG Description: Container for information related to the line secondary
output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_secondary_out must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__line_secondary_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_secondary_out(self):
    self.__line_secondary_out = YANGDynClass(base=yc_line_secondary_out_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_line_secondary_out, is_container='container', yang_name="line-secondary-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_common_in(self):
    """
    Getter method for common_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in (container)

    YANG Description: Container for information related to the line common
input port
    """
    return self.__common_in
      
  def _set_common_in(self, v, load=False):
    """
    Setter method for common_in, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_in (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_common_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_common_in() directly.

    YANG Description: Container for information related to the line common
input port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """common_in must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__common_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_common_in(self):
    self.__common_in = YANGDynClass(base=yc_common_in_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_in, is_container='container', yang_name="common-in", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_common_output(self):
    """
    Getter method for common_output, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output (container)

    YANG Description: Container for information related to the line common
output port
    """
    return self.__common_output
      
  def _set_common_output(self, v, load=False):
    """
    Setter method for common_output, mapped from YANG variable /aps/aps_modules/aps_module/ports/common_output (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_common_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_common_output() directly.

    YANG Description: Container for information related to the line common
output port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """common_output must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__common_output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_common_output(self):
    self.__common_output = YANGDynClass(base=yc_common_output_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports_common_output, is_container='container', yang_name="common-output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  line_primary_in = __builtin__.property(_get_line_primary_in, _set_line_primary_in)
  line_primary_out = __builtin__.property(_get_line_primary_out, _set_line_primary_out)
  line_secondary_in = __builtin__.property(_get_line_secondary_in, _set_line_secondary_in)
  line_secondary_out = __builtin__.property(_get_line_secondary_out, _set_line_secondary_out)
  common_in = __builtin__.property(_get_common_in, _set_common_in)
  common_output = __builtin__.property(_get_common_output, _set_common_output)


  _pyangbind_elements = {'line_primary_in': line_primary_in, 'line_primary_out': line_primary_out, 'line_secondary_in': line_secondary_in, 'line_secondary_out': line_secondary_out, 'common_in': common_in, 'common_output': common_output, }


class yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of automatic protection switch modules present
in the device
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__config','__state','__ports',)

  _yang_name = 'aps-module'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    self.__ports = YANGDynClass(base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules', u'aps-module']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/name (leafref)

    YANG Description: Reference to the config name list key
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the config name list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /aps/aps_modules/aps_module/config (container)

    YANG Description: Configuration data for an automatic protection
switch module
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /aps/aps_modules/aps_module/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for an automatic protection
switch module
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_transport_line_protection__aps_aps_modules_aps_module_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /aps/aps_modules/aps_module/state (container)

    YANG Description: Operational state data for an automatic protection
switch module
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /aps/aps_modules/aps_module/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for an automatic protection
switch module
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_transport_line_protection__aps_aps_modules_aps_module_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)


  def _get_ports(self):
    """
    Getter method for ports, mapped from YANG variable /aps/aps_modules/aps_module/ports (container)

    YANG Description: Top level grouping for automatic protection switch ports
    """
    return self.__ports
      
  def _set_ports(self, v, load=False):
    """
    Setter method for ports, mapped from YANG variable /aps/aps_modules/aps_module/ports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ports() directly.

    YANG Description: Top level grouping for automatic protection switch ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ports(self):
    self.__ports = YANGDynClass(base=yc_ports_openconfig_transport_line_protection__aps_aps_modules_aps_module_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  ports = __builtin__.property(_get_ports, _set_ports)


  _pyangbind_elements = {'name': name, 'config': config, 'state': state, 'ports': ports, }


class yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of automatic protection
switch modules
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__aps_module',)

  _yang_name = 'aps-modules'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps_module = YANGDynClass(base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps', u'aps-modules']

  def _get_aps_module(self):
    """
    Getter method for aps_module, mapped from YANG variable /aps/aps_modules/aps_module (list)

    YANG Description: List of automatic protection switch modules present
in the device
    """
    return self.__aps_module
      
  def _set_aps_module(self, v, load=False):
    """
    Setter method for aps_module, mapped from YANG variable /aps/aps_modules/aps_module (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps_module() directly.

    YANG Description: List of automatic protection switch modules present
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps_module must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)""",
        })

    self.__aps_module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps_module(self):
    self.__aps_module = YANGDynClass(base=YANGListType("name",yc_aps_module_openconfig_transport_line_protection__aps_aps_modules_aps_module, yang_name="aps-module", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="aps-module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='list', is_config=True)

  aps_module = __builtin__.property(_get_aps_module, _set_aps_module)


  _pyangbind_elements = {'aps_module': aps_module, }


class yc_aps_openconfig_transport_line_protection__aps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level grouping for automatic protection switch data
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__aps_modules',)

  _yang_name = 'aps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps_modules = YANGDynClass(base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'aps']

  def _get_aps_modules(self):
    """
    Getter method for aps_modules, mapped from YANG variable /aps/aps_modules (container)

    YANG Description: Enclosing container for list of automatic protection
switch modules
    """
    return self.__aps_modules
      
  def _set_aps_modules(self, v, load=False):
    """
    Setter method for aps_modules, mapped from YANG variable /aps/aps_modules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps_modules() directly.

    YANG Description: Enclosing container for list of automatic protection
switch modules
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps_modules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__aps_modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps_modules(self):
    self.__aps_modules = YANGDynClass(base=yc_aps_modules_openconfig_transport_line_protection__aps_aps_modules, is_container='container', yang_name="aps-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  aps_modules = __builtin__.property(_get_aps_modules, _set_aps_modules)


  _pyangbind_elements = {'aps_modules': aps_modules, }


class openconfig_transport_line_protection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /openconfig-transport-line-protection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical line protection elements, deployed as part of a
transport line system. An Automatic Protection Switch (APS)
is typically installed in the same device as the amplifiers
and wave-router, however an APS can also be a standalone
device. In both scenarios, it serves the same purpose of
providing protection using two dark fiber pairs to ensure the
amplifiers can still receive a signal if one of the two fiber
pairs is broken.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__aps',)

  _yang_name = 'openconfig-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps = YANGDynClass(base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_aps(self):
    """
    Getter method for aps, mapped from YANG variable /aps (container)

    YANG Description: Top level grouping for automatic protection switch data
    """
    return self.__aps
      
  def _set_aps(self, v, load=False):
    """
    Setter method for aps, mapped from YANG variable /aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps() directly.

    YANG Description: Top level grouping for automatic protection switch data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps(self):
    self.__aps = YANGDynClass(base=yc_aps_openconfig_transport_line_protection__aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  aps = __builtin__.property(_get_aps, _set_aps)


  _pyangbind_elements = {'aps': aps, }


