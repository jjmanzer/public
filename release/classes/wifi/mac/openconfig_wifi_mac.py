
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
  unicode = str
elif six.PY2:
  import __builtin__

class yc_config_openconfig_wifi_mac__ssids_ssid_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable items at the global, ssid level
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__enabled','__hidden','__vlan_id','__operating_frequency','__basic_data_rates','__supported_data_rates','__broadcast_filter','__multicast_filter','__ipv6_ndp_filter','__ipv6_ndp_filter_timer','__station_isolation','__opmode','__wpa2_psk','__server_group','__dva','__dhcp_required','__qbss_load','__advertise_apname','__csa','__ptk_timeout','__gtk_timeout','__dot11k','__okc',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__server_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=True)
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__basic_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__supported_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ssids/ssid/config/name (string)

    YANG Description: The name of the SSID.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ssids/ssid/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /ssids/ssid/config/enabled (boolean)

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /ssids/ssid/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /ssids/ssid/config/hidden (boolean)

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /ssids/ssid/config/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /ssids/ssid/config/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Optional VLAN tag used by the SSID. When unspecified, defaults
to untagged.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /ssids/ssid/config/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: Optional VLAN tag used by the SSID. When unspecified, defaults
to untagged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=True)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=True)


  def _get_operating_frequency(self):
    """
    Getter method for operating_frequency, mapped from YANG variable /ssids/ssid/config/operating_frequency (identityref)

    YANG Description: Operating frequency of this SSID. When none specified, the default is
dual-band.
    """
    return self.__operating_frequency
      
  def _set_operating_frequency(self, v, load=False):
    """
    Setter method for operating_frequency, mapped from YANG variable /ssids/ssid/config/operating_frequency (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_frequency() directly.

    YANG Description: Operating frequency of this SSID. When none specified, the default is
dual-band.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_frequency must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)""",
        })

    self.__operating_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_frequency(self):
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)


  def _get_basic_data_rates(self):
    """
    Getter method for basic_data_rates, mapped from YANG variable /ssids/ssid/config/basic_data_rates (identityref)

    YANG Description: Basic data-rates for the SSID.
    """
    return self.__basic_data_rates
      
  def _set_basic_data_rates(self, v, load=False):
    """
    Setter method for basic_data_rates, mapped from YANG variable /ssids/ssid/config/basic_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_basic_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_basic_data_rates() directly.

    YANG Description: Basic data-rates for the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """basic_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)""",
        })

    self.__basic_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_basic_data_rates(self):
    self.__basic_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)


  def _get_supported_data_rates(self):
    """
    Getter method for supported_data_rates, mapped from YANG variable /ssids/ssid/config/supported_data_rates (identityref)

    YANG Description: Supported data-rates for the SSID.
    """
    return self.__supported_data_rates
      
  def _set_supported_data_rates(self, v, load=False):
    """
    Setter method for supported_data_rates, mapped from YANG variable /ssids/ssid/config/supported_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_data_rates() directly.

    YANG Description: Supported data-rates for the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)""",
        })

    self.__supported_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_data_rates(self):
    self.__supported_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=True)


  def _get_broadcast_filter(self):
    """
    Getter method for broadcast_filter, mapped from YANG variable /ssids/ssid/config/broadcast_filter (boolean)

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    return self.__broadcast_filter
      
  def _set_broadcast_filter(self, v, load=False):
    """
    Setter method for broadcast_filter, mapped from YANG variable /ssids/ssid/config/broadcast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_broadcast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_broadcast_filter() directly.

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """broadcast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__broadcast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_broadcast_filter(self):
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_multicast_filter(self):
    """
    Getter method for multicast_filter, mapped from YANG variable /ssids/ssid/config/multicast_filter (boolean)

    YANG Description: Drop all downstream Multicast packets.
    """
    return self.__multicast_filter
      
  def _set_multicast_filter(self, v, load=False):
    """
    Setter method for multicast_filter, mapped from YANG variable /ssids/ssid/config/multicast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicast_filter() directly.

    YANG Description: Drop all downstream Multicast packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multicast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__multicast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicast_filter(self):
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_ipv6_ndp_filter(self):
    """
    Getter method for ipv6_ndp_filter, mapped from YANG variable /ssids/ssid/config/ipv6_ndp_filter (boolean)

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    return self.__ipv6_ndp_filter
      
  def _set_ipv6_ndp_filter(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter, mapped from YANG variable /ssids/ssid/config/ipv6_ndp_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter() directly.

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__ipv6_ndp_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter(self):
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_ipv6_ndp_filter_timer(self):
    """
    Getter method for ipv6_ndp_filter_timer, mapped from YANG variable /ssids/ssid/config/ipv6_ndp_filter_timer (uint16)

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    return self.__ipv6_ndp_filter_timer
      
  def _set_ipv6_ndp_filter_timer(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter_timer, mapped from YANG variable /ssids/ssid/config/ipv6_ndp_filter_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter_timer() directly.

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__ipv6_ndp_filter_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter_timer(self):
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)


  def _get_station_isolation(self):
    """
    Getter method for station_isolation, mapped from YANG variable /ssids/ssid/config/station_isolation (boolean)

    YANG Description: Block Station peer to peer communication.
    """
    return self.__station_isolation
      
  def _set_station_isolation(self, v, load=False):
    """
    Setter method for station_isolation, mapped from YANG variable /ssids/ssid/config/station_isolation (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_station_isolation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_station_isolation() directly.

    YANG Description: Block Station peer to peer communication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """station_isolation must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__station_isolation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_station_isolation(self):
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_opmode(self):
    """
    Getter method for opmode, mapped from YANG variable /ssids/ssid/config/opmode (enumeration)

    YANG Description: The type of Layer2 authentication in use.
    """
    return self.__opmode
      
  def _set_opmode(self, v, load=False):
    """
    Setter method for opmode, mapped from YANG variable /ssids/ssid/config/opmode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opmode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opmode() directly.

    YANG Description: The type of Layer2 authentication in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opmode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wifi-mac:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)""",
        })

    self.__opmode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opmode(self):
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)


  def _get_wpa2_psk(self):
    """
    Getter method for wpa2_psk, mapped from YANG variable /ssids/ssid/config/wpa2_psk (string)

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    return self.__wpa2_psk
      
  def _set_wpa2_psk(self, v, load=False):
    """
    Setter method for wpa2_psk, mapped from YANG variable /ssids/ssid/config/wpa2_psk (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wpa2_psk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wpa2_psk() directly.

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wpa2_psk must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)""",
        })

    self.__wpa2_psk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wpa2_psk(self):
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)


  def _get_server_group(self):
    """
    Getter method for server_group, mapped from YANG variable /ssids/ssid/config/server_group (string)

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    return self.__server_group
      
  def _set_server_group(self, v, load=False):
    """
    Setter method for server_group, mapped from YANG variable /ssids/ssid/config/server_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_group() directly.

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)""",
        })

    self.__server_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_group(self):
    self.__server_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=True)


  def _get_dva(self):
    """
    Getter method for dva, mapped from YANG variable /ssids/ssid/config/dva (boolean)

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    return self.__dva
      
  def _set_dva(self, v, load=False):
    """
    Setter method for dva, mapped from YANG variable /ssids/ssid/config/dva (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dva is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dva() directly.

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dva must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dva = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dva(self):
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_dhcp_required(self):
    """
    Getter method for dhcp_required, mapped from YANG variable /ssids/ssid/config/dhcp_required (boolean)

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    return self.__dhcp_required
      
  def _set_dhcp_required(self, v, load=False):
    """
    Setter method for dhcp_required, mapped from YANG variable /ssids/ssid/config/dhcp_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_required() directly.

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_required(self):
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_qbss_load(self):
    """
    Getter method for qbss_load, mapped from YANG variable /ssids/ssid/config/qbss_load (boolean)

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    return self.__qbss_load
      
  def _set_qbss_load(self, v, load=False):
    """
    Setter method for qbss_load, mapped from YANG variable /ssids/ssid/config/qbss_load (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qbss_load is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qbss_load() directly.

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qbss_load must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__qbss_load = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qbss_load(self):
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_advertise_apname(self):
    """
    Getter method for advertise_apname, mapped from YANG variable /ssids/ssid/config/advertise_apname (boolean)

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    return self.__advertise_apname
      
  def _set_advertise_apname(self, v, load=False):
    """
    Setter method for advertise_apname, mapped from YANG variable /ssids/ssid/config/advertise_apname (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_apname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_apname() directly.

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_apname must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_apname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_apname(self):
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_csa(self):
    """
    Getter method for csa, mapped from YANG variable /ssids/ssid/config/csa (boolean)

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    return self.__csa
      
  def _set_csa(self, v, load=False):
    """
    Setter method for csa, mapped from YANG variable /ssids/ssid/config/csa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_csa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_csa() directly.

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """csa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__csa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_csa(self):
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_ptk_timeout(self):
    """
    Getter method for ptk_timeout, mapped from YANG variable /ssids/ssid/config/ptk_timeout (uint16)

    YANG Description: Time, in seconds, for the Pairwise Transient Key to be timed out.
    """
    return self.__ptk_timeout
      
  def _set_ptk_timeout(self, v, load=False):
    """
    Setter method for ptk_timeout, mapped from YANG variable /ssids/ssid/config/ptk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptk_timeout() directly.

    YANG Description: Time, in seconds, for the Pairwise Transient Key to be timed out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__ptk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptk_timeout(self):
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)


  def _get_gtk_timeout(self):
    """
    Getter method for gtk_timeout, mapped from YANG variable /ssids/ssid/config/gtk_timeout (uint16)

    YANG Description: TTL for the Group Temporal Key.
    """
    return self.__gtk_timeout
      
  def _set_gtk_timeout(self, v, load=False):
    """
    Setter method for gtk_timeout, mapped from YANG variable /ssids/ssid/config/gtk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gtk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gtk_timeout() directly.

    YANG Description: TTL for the Group Temporal Key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gtk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__gtk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gtk_timeout(self):
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)


  def _get_dot11k(self):
    """
    Getter method for dot11k, mapped from YANG variable /ssids/ssid/config/dot11k (boolean)

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    return self.__dot11k
      
  def _set_dot11k(self, v, load=False):
    """
    Setter method for dot11k, mapped from YANG variable /ssids/ssid/config/dot11k (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11k is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11k() directly.

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11k must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dot11k = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11k(self):
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_okc(self):
    """
    Getter method for okc, mapped from YANG variable /ssids/ssid/config/okc (boolean)

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    return self.__okc
      
  def _set_okc(self, v, load=False):
    """
    Setter method for okc, mapped from YANG variable /ssids/ssid/config/okc (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_okc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_okc() directly.

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """okc must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__okc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_okc(self):
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  hidden = __builtin__.property(_get_hidden, _set_hidden)
  vlan_id = __builtin__.property(_get_vlan_id, _set_vlan_id)
  operating_frequency = __builtin__.property(_get_operating_frequency, _set_operating_frequency)
  basic_data_rates = __builtin__.property(_get_basic_data_rates, _set_basic_data_rates)
  supported_data_rates = __builtin__.property(_get_supported_data_rates, _set_supported_data_rates)
  broadcast_filter = __builtin__.property(_get_broadcast_filter, _set_broadcast_filter)
  multicast_filter = __builtin__.property(_get_multicast_filter, _set_multicast_filter)
  ipv6_ndp_filter = __builtin__.property(_get_ipv6_ndp_filter, _set_ipv6_ndp_filter)
  ipv6_ndp_filter_timer = __builtin__.property(_get_ipv6_ndp_filter_timer, _set_ipv6_ndp_filter_timer)
  station_isolation = __builtin__.property(_get_station_isolation, _set_station_isolation)
  opmode = __builtin__.property(_get_opmode, _set_opmode)
  wpa2_psk = __builtin__.property(_get_wpa2_psk, _set_wpa2_psk)
  server_group = __builtin__.property(_get_server_group, _set_server_group)
  dva = __builtin__.property(_get_dva, _set_dva)
  dhcp_required = __builtin__.property(_get_dhcp_required, _set_dhcp_required)
  qbss_load = __builtin__.property(_get_qbss_load, _set_qbss_load)
  advertise_apname = __builtin__.property(_get_advertise_apname, _set_advertise_apname)
  csa = __builtin__.property(_get_csa, _set_csa)
  ptk_timeout = __builtin__.property(_get_ptk_timeout, _set_ptk_timeout)
  gtk_timeout = __builtin__.property(_get_gtk_timeout, _set_gtk_timeout)
  dot11k = __builtin__.property(_get_dot11k, _set_dot11k)
  okc = __builtin__.property(_get_okc, _set_okc)


  _pyangbind_elements = {'name': name, 'enabled': enabled, 'hidden': hidden, 'vlan_id': vlan_id, 'operating_frequency': operating_frequency, 'basic_data_rates': basic_data_rates, 'supported_data_rates': supported_data_rates, 'broadcast_filter': broadcast_filter, 'multicast_filter': multicast_filter, 'ipv6_ndp_filter': ipv6_ndp_filter, 'ipv6_ndp_filter_timer': ipv6_ndp_filter_timer, 'station_isolation': station_isolation, 'opmode': opmode, 'wpa2_psk': wpa2_psk, 'server_group': server_group, 'dva': dva, 'dhcp_required': dhcp_required, 'qbss_load': qbss_load, 'advertise_apname': advertise_apname, 'csa': csa, 'ptk_timeout': ptk_timeout, 'gtk_timeout': gtk_timeout, 'dot11k': dot11k, 'okc': okc, }


class yc_rx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_dist(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters/rx-data-dist. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The distribution of Data frame sizes in bytes of successfully recieved
AMPDU, or MPDU for non-aggregated, frames.
The distribution should characterize frame sizes starting at 64 bytes
or less with the bin size doubling for each successive bin to a
maximum of 1MB or larger, as represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__rx_0_64','__rx_65_128','__rx_129_256','__rx_257_512','__rx_513_1024','__rx_1025_2048','__rx_2049_4096','__rx_4097_8192','__rx_8193_16384','__rx_16385_32768','__rx_32769_65536','__rx_65537_131072','__rx_131073_262144','__rx_262145_524288','__rx_524289_1048576',)

  _yang_name = 'rx-data-dist'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters', u'rx-data-dist']

  def _get_rx_0_64(self):
    """
    Getter method for rx_0_64, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_0_64 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    return self.__rx_0_64
      
  def _set_rx_0_64(self, v, load=False):
    """
    Setter method for rx_0_64, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_0_64 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_0_64 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_0_64() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_0_64 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_0_64 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_0_64(self):
    self.__rx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_65_128(self):
    """
    Getter method for rx_65_128, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_65_128 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    return self.__rx_65_128
      
  def _set_rx_65_128(self, v, load=False):
    """
    Setter method for rx_65_128, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_65_128 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_65_128 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_65_128() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_65_128 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_65_128 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_65_128(self):
    self.__rx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_129_256(self):
    """
    Getter method for rx_129_256, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_129_256 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    return self.__rx_129_256
      
  def _set_rx_129_256(self, v, load=False):
    """
    Setter method for rx_129_256, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_129_256 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_129_256 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_129_256() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_129_256 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_129_256 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_129_256(self):
    self.__rx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_257_512(self):
    """
    Getter method for rx_257_512, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_257_512 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    return self.__rx_257_512
      
  def _set_rx_257_512(self, v, load=False):
    """
    Setter method for rx_257_512, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_257_512 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_257_512 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_257_512() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_257_512 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_257_512 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_257_512(self):
    self.__rx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_513_1024(self):
    """
    Getter method for rx_513_1024, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_513_1024 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    return self.__rx_513_1024
      
  def _set_rx_513_1024(self, v, load=False):
    """
    Setter method for rx_513_1024, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_513_1024 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_513_1024 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_513_1024() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_513_1024 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_513_1024 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_513_1024(self):
    self.__rx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_1025_2048(self):
    """
    Getter method for rx_1025_2048, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_1025_2048 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    return self.__rx_1025_2048
      
  def _set_rx_1025_2048(self, v, load=False):
    """
    Setter method for rx_1025_2048, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_1025_2048 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_1025_2048 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_1025_2048() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_1025_2048 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_1025_2048 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_1025_2048(self):
    self.__rx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_2049_4096(self):
    """
    Getter method for rx_2049_4096, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_2049_4096 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    return self.__rx_2049_4096
      
  def _set_rx_2049_4096(self, v, load=False):
    """
    Setter method for rx_2049_4096, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_2049_4096 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_2049_4096 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_2049_4096() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_2049_4096 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_2049_4096 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_2049_4096(self):
    self.__rx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_4097_8192(self):
    """
    Getter method for rx_4097_8192, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_4097_8192 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    return self.__rx_4097_8192
      
  def _set_rx_4097_8192(self, v, load=False):
    """
    Setter method for rx_4097_8192, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_4097_8192 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_4097_8192 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_4097_8192() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_4097_8192 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_4097_8192 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_4097_8192(self):
    self.__rx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_8193_16384(self):
    """
    Getter method for rx_8193_16384, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_8193_16384 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    return self.__rx_8193_16384
      
  def _set_rx_8193_16384(self, v, load=False):
    """
    Setter method for rx_8193_16384, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_8193_16384 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_8193_16384 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_8193_16384() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_8193_16384 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_8193_16384 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_8193_16384(self):
    self.__rx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_16385_32768(self):
    """
    Getter method for rx_16385_32768, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_16385_32768 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    return self.__rx_16385_32768
      
  def _set_rx_16385_32768(self, v, load=False):
    """
    Setter method for rx_16385_32768, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_16385_32768 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_16385_32768 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_16385_32768() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_16385_32768 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_16385_32768 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_16385_32768(self):
    self.__rx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_32769_65536(self):
    """
    Getter method for rx_32769_65536, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_32769_65536 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    return self.__rx_32769_65536
      
  def _set_rx_32769_65536(self, v, load=False):
    """
    Setter method for rx_32769_65536, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_32769_65536 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_32769_65536 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_32769_65536() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_32769_65536 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_32769_65536 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_32769_65536(self):
    self.__rx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_65537_131072(self):
    """
    Getter method for rx_65537_131072, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_65537_131072 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    return self.__rx_65537_131072
      
  def _set_rx_65537_131072(self, v, load=False):
    """
    Setter method for rx_65537_131072, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_65537_131072 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_65537_131072 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_65537_131072() directly.

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_65537_131072 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_65537_131072 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_65537_131072(self):
    self.__rx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_131073_262144(self):
    """
    Getter method for rx_131073_262144, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_131073_262144 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    return self.__rx_131073_262144
      
  def _set_rx_131073_262144(self, v, load=False):
    """
    Setter method for rx_131073_262144, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_131073_262144 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_131073_262144 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_131073_262144() directly.

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_131073_262144 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_131073_262144 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_131073_262144(self):
    self.__rx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_262145_524288(self):
    """
    Getter method for rx_262145_524288, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_262145_524288 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    return self.__rx_262145_524288
      
  def _set_rx_262145_524288(self, v, load=False):
    """
    Setter method for rx_262145_524288, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_262145_524288 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_262145_524288 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_262145_524288() directly.

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_262145_524288 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_262145_524288 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_262145_524288(self):
    self.__rx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_524289_1048576(self):
    """
    Getter method for rx_524289_1048576, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_524289_1048576 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    return self.__rx_524289_1048576
      
  def _set_rx_524289_1048576(self, v, load=False):
    """
    Setter method for rx_524289_1048576, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist/rx_524289_1048576 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_524289_1048576 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_524289_1048576() directly.

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_524289_1048576 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_524289_1048576 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_524289_1048576(self):
    self.__rx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  rx_0_64 = __builtin__.property(_get_rx_0_64)
  rx_65_128 = __builtin__.property(_get_rx_65_128)
  rx_129_256 = __builtin__.property(_get_rx_129_256)
  rx_257_512 = __builtin__.property(_get_rx_257_512)
  rx_513_1024 = __builtin__.property(_get_rx_513_1024)
  rx_1025_2048 = __builtin__.property(_get_rx_1025_2048)
  rx_2049_4096 = __builtin__.property(_get_rx_2049_4096)
  rx_4097_8192 = __builtin__.property(_get_rx_4097_8192)
  rx_8193_16384 = __builtin__.property(_get_rx_8193_16384)
  rx_16385_32768 = __builtin__.property(_get_rx_16385_32768)
  rx_32769_65536 = __builtin__.property(_get_rx_32769_65536)
  rx_65537_131072 = __builtin__.property(_get_rx_65537_131072)
  rx_131073_262144 = __builtin__.property(_get_rx_131073_262144)
  rx_262145_524288 = __builtin__.property(_get_rx_262145_524288)
  rx_524289_1048576 = __builtin__.property(_get_rx_524289_1048576)


  _pyangbind_elements = {'rx_0_64': rx_0_64, 'rx_65_128': rx_65_128, 'rx_129_256': rx_129_256, 'rx_257_512': rx_257_512, 'rx_513_1024': rx_513_1024, 'rx_1025_2048': rx_1025_2048, 'rx_2049_4096': rx_2049_4096, 'rx_4097_8192': rx_4097_8192, 'rx_8193_16384': rx_8193_16384, 'rx_16385_32768': rx_16385_32768, 'rx_32769_65536': rx_32769_65536, 'rx_65537_131072': rx_65537_131072, 'rx_131073_262144': rx_131073_262144, 'rx_262145_524288': rx_262145_524288, 'rx_524289_1048576': rx_524289_1048576, }


class yc_rx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_wmm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters/rx-data-wmm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Received 802.11 Data frames, per WMM Access Category.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__vi','__vo','__be','__bk',)

  _yang_name = 'rx-data-wmm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters', u'rx-data-wmm']

  def _get_vi(self):
    """
    Getter method for vi, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/vi (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Video.
    """
    return self.__vi
      
  def _set_vi(self, v, load=False):
    """
    Setter method for vi, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/vi (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vi() directly.

    YANG Description: Rx Data frames marked as Access Category Video.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vi must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vi(self):
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_vo(self):
    """
    Getter method for vo, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/vo (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Voice.
    """
    return self.__vo
      
  def _set_vo(self, v, load=False):
    """
    Setter method for vo, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/vo (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vo() directly.

    YANG Description: Rx Data frames marked as Access Category Voice.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vo must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vo(self):
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_be(self):
    """
    Getter method for be, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/be (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Best Effort.
    """
    return self.__be
      
  def _set_be(self, v, load=False):
    """
    Setter method for be, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/be (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_be is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_be() directly.

    YANG Description: Rx Data frames marked as Access Category Best Effort.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """be must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__be = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_be(self):
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_bk(self):
    """
    Getter method for bk, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/bk (oc-yang:counter64)

    YANG Description: Rx Data frames marked as Access Category Background.
    """
    return self.__bk
      
  def _set_bk(self, v, load=False):
    """
    Setter method for bk, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm/bk (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bk() directly.

    YANG Description: Rx Data frames marked as Access Category Background.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bk must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__bk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bk(self):
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  vi = __builtin__.property(_get_vi)
  vo = __builtin__.property(_get_vo)
  be = __builtin__.property(_get_be)
  bk = __builtin__.property(_get_bk)


  _pyangbind_elements = {'vi': vi, 'vo': vo, 'be': be, 'bk': bk, }


class yc_rx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_rx_mcs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters/rx-mcs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Received Data frames, per MCS Index. It is expected that vendors
bucketize 802.11n MCS frames in their matching 802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mcs0','__mcs1','__mcs2','__mcs3','__mcs4','__mcs5','__mcs6','__mcs7','__mcs8','__mcs9',)

  _yang_name = 'rx-mcs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters', u'rx-mcs']

  def _get_mcs0(self):
    """
    Getter method for mcs0, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs0 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 0.
    """
    return self.__mcs0
      
  def _set_mcs0(self, v, load=False):
    """
    Setter method for mcs0, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs0 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs0 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs0() directly.

    YANG Description: Rx Data frames at MCS 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs0 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs0 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs0(self):
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs1(self):
    """
    Getter method for mcs1, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs1 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 1.
    """
    return self.__mcs1
      
  def _set_mcs1(self, v, load=False):
    """
    Setter method for mcs1, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs1 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs1() directly.

    YANG Description: Rx Data frames at MCS 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs1 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs1(self):
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs2(self):
    """
    Getter method for mcs2, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs2 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 2.
    """
    return self.__mcs2
      
  def _set_mcs2(self, v, load=False):
    """
    Setter method for mcs2, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs2 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs2() directly.

    YANG Description: Rx Data frames at MCS 2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs2 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs2(self):
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs3(self):
    """
    Getter method for mcs3, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs3 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 3.
    """
    return self.__mcs3
      
  def _set_mcs3(self, v, load=False):
    """
    Setter method for mcs3, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs3 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs3() directly.

    YANG Description: Rx Data frames at MCS 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs3 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs3(self):
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs4(self):
    """
    Getter method for mcs4, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs4 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 4.
    """
    return self.__mcs4
      
  def _set_mcs4(self, v, load=False):
    """
    Setter method for mcs4, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs4 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs4() directly.

    YANG Description: Rx Data frames at MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs4 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs4(self):
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs5(self):
    """
    Getter method for mcs5, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs5 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 5.
    """
    return self.__mcs5
      
  def _set_mcs5(self, v, load=False):
    """
    Setter method for mcs5, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs5 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs5() directly.

    YANG Description: Rx Data frames at MCS 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs5 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs5(self):
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs6(self):
    """
    Getter method for mcs6, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs6 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 6.
    """
    return self.__mcs6
      
  def _set_mcs6(self, v, load=False):
    """
    Setter method for mcs6, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs6 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs6() directly.

    YANG Description: Rx Data frames at MCS 6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs6 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs6(self):
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs7(self):
    """
    Getter method for mcs7, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs7 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 7.
    """
    return self.__mcs7
      
  def _set_mcs7(self, v, load=False):
    """
    Setter method for mcs7, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs7 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs7() directly.

    YANG Description: Rx Data frames at MCS 7.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs7 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs7(self):
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs8(self):
    """
    Getter method for mcs8, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs8 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 8.
    """
    return self.__mcs8
      
  def _set_mcs8(self, v, load=False):
    """
    Setter method for mcs8, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs8 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs8 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs8() directly.

    YANG Description: Rx Data frames at MCS 8.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs8 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs8 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs8(self):
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs9(self):
    """
    Getter method for mcs9, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs9 (oc-yang:counter64)

    YANG Description: Rx Data frames at MCS 9.
    """
    return self.__mcs9
      
  def _set_mcs9(self, v, load=False):
    """
    Setter method for mcs9, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs/mcs9 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs9 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs9() directly.

    YANG Description: Rx Data frames at MCS 9.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs9 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs9 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs9(self):
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  mcs0 = __builtin__.property(_get_mcs0)
  mcs1 = __builtin__.property(_get_mcs1)
  mcs2 = __builtin__.property(_get_mcs2)
  mcs3 = __builtin__.property(_get_mcs3)
  mcs4 = __builtin__.property(_get_mcs4)
  mcs5 = __builtin__.property(_get_mcs5)
  mcs6 = __builtin__.property(_get_mcs6)
  mcs7 = __builtin__.property(_get_mcs7)
  mcs8 = __builtin__.property(_get_mcs8)
  mcs9 = __builtin__.property(_get_mcs9)


  _pyangbind_elements = {'mcs0': mcs0, 'mcs1': mcs1, 'mcs2': mcs2, 'mcs3': mcs3, 'mcs4': mcs4, 'mcs5': mcs5, 'mcs6': mcs6, 'mcs7': mcs7, 'mcs8': mcs8, 'mcs9': mcs9, }


class yc_tx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_dist(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters/tx-data-dist. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The distribution of Data frame sizes in bytes of successfully transmitted
AMPDU, or MPDU for non-aggregated, frames.
The distribution should characterize frame sizes starting at 64 bytes
or less with the bin size doubling for each successive bin to a
maximum of 1MB or larger, as represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__tx_0_64','__tx_65_128','__tx_129_256','__tx_257_512','__tx_513_1024','__tx_1025_2048','__tx_2049_4096','__tx_4097_8192','__tx_8193_16384','__tx_16385_32768','__tx_32769_65536','__tx_65537_131072','__tx_131073_262144','__tx_262145_524288','__tx_524289_1048576',)

  _yang_name = 'tx-data-dist'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters', u'tx-data-dist']

  def _get_tx_0_64(self):
    """
    Getter method for tx_0_64, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_0_64 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    return self.__tx_0_64
      
  def _set_tx_0_64(self, v, load=False):
    """
    Setter method for tx_0_64, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_0_64 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_0_64 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_0_64() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 0 to 64 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_0_64 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_0_64 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_0_64(self):
    self.__tx_0_64 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-0-64", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_65_128(self):
    """
    Getter method for tx_65_128, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_65_128 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    return self.__tx_65_128
      
  def _set_tx_65_128(self, v, load=False):
    """
    Setter method for tx_65_128, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_65_128 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_65_128 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_65_128() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 65 to 128 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_65_128 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_65_128 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_65_128(self):
    self.__tx_65_128 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65-128", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_129_256(self):
    """
    Getter method for tx_129_256, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_129_256 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    return self.__tx_129_256
      
  def _set_tx_129_256(self, v, load=False):
    """
    Setter method for tx_129_256, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_129_256 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_129_256 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_129_256() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 129 to 256 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_129_256 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_129_256 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_129_256(self):
    self.__tx_129_256 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-129-256", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_257_512(self):
    """
    Getter method for tx_257_512, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_257_512 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    return self.__tx_257_512
      
  def _set_tx_257_512(self, v, load=False):
    """
    Setter method for tx_257_512, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_257_512 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_257_512 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_257_512() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 257 to 512 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_257_512 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_257_512 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_257_512(self):
    self.__tx_257_512 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-257-512", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_513_1024(self):
    """
    Getter method for tx_513_1024, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_513_1024 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    return self.__tx_513_1024
      
  def _set_tx_513_1024(self, v, load=False):
    """
    Setter method for tx_513_1024, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_513_1024 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_513_1024 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_513_1024() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 513 to 1024 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_513_1024 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_513_1024 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_513_1024(self):
    self.__tx_513_1024 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-513-1024", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_1025_2048(self):
    """
    Getter method for tx_1025_2048, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_1025_2048 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    return self.__tx_1025_2048
      
  def _set_tx_1025_2048(self, v, load=False):
    """
    Setter method for tx_1025_2048, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_1025_2048 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_1025_2048 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_1025_2048() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 1025 to 2048 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_1025_2048 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_1025_2048 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_1025_2048(self):
    self.__tx_1025_2048 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-1025-2048", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_2049_4096(self):
    """
    Getter method for tx_2049_4096, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_2049_4096 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    return self.__tx_2049_4096
      
  def _set_tx_2049_4096(self, v, load=False):
    """
    Setter method for tx_2049_4096, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_2049_4096 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_2049_4096 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_2049_4096() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 2049 to 4096 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_2049_4096 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_2049_4096 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_2049_4096(self):
    self.__tx_2049_4096 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-2049-4096", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_4097_8192(self):
    """
    Getter method for tx_4097_8192, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_4097_8192 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    return self.__tx_4097_8192
      
  def _set_tx_4097_8192(self, v, load=False):
    """
    Setter method for tx_4097_8192, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_4097_8192 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_4097_8192 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_4097_8192() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 4097 to 8192 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_4097_8192 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_4097_8192 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_4097_8192(self):
    self.__tx_4097_8192 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-4097-8192", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_8193_16384(self):
    """
    Getter method for tx_8193_16384, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_8193_16384 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    return self.__tx_8193_16384
      
  def _set_tx_8193_16384(self, v, load=False):
    """
    Setter method for tx_8193_16384, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_8193_16384 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_8193_16384 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_8193_16384() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 8193 to 16384 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_8193_16384 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_8193_16384 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_8193_16384(self):
    self.__tx_8193_16384 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-8193-16384", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_16385_32768(self):
    """
    Getter method for tx_16385_32768, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_16385_32768 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    return self.__tx_16385_32768
      
  def _set_tx_16385_32768(self, v, load=False):
    """
    Setter method for tx_16385_32768, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_16385_32768 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_16385_32768 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_16385_32768() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 16385 to 32768 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_16385_32768 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_16385_32768 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_16385_32768(self):
    self.__tx_16385_32768 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-16385-32768", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_32769_65536(self):
    """
    Getter method for tx_32769_65536, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_32769_65536 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    return self.__tx_32769_65536
      
  def _set_tx_32769_65536(self, v, load=False):
    """
    Setter method for tx_32769_65536, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_32769_65536 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_32769_65536 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_32769_65536() directly.

    YANG Description: Transmitted AMPDU or MPDUs from 32769 to 65536 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_32769_65536 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_32769_65536 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_32769_65536(self):
    self.__tx_32769_65536 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-32769-65536", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_65537_131072(self):
    """
    Getter method for tx_65537_131072, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_65537_131072 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    return self.__tx_65537_131072
      
  def _set_tx_65537_131072(self, v, load=False):
    """
    Setter method for tx_65537_131072, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_65537_131072 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_65537_131072 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_65537_131072() directly.

    YANG Description: Transmitted AMPDU from 65537 to 131072 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_65537_131072 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_65537_131072 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_65537_131072(self):
    self.__tx_65537_131072 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-65537-131072", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_131073_262144(self):
    """
    Getter method for tx_131073_262144, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_131073_262144 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    return self.__tx_131073_262144
      
  def _set_tx_131073_262144(self, v, load=False):
    """
    Setter method for tx_131073_262144, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_131073_262144 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_131073_262144 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_131073_262144() directly.

    YANG Description: Transmitted AMPDU from 131073 to 262144 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_131073_262144 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_131073_262144 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_131073_262144(self):
    self.__tx_131073_262144 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-131073-262144", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_262145_524288(self):
    """
    Getter method for tx_262145_524288, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_262145_524288 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    return self.__tx_262145_524288
      
  def _set_tx_262145_524288(self, v, load=False):
    """
    Setter method for tx_262145_524288, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_262145_524288 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_262145_524288 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_262145_524288() directly.

    YANG Description: Transmitted AMPDU from 262145 to 524288 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_262145_524288 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_262145_524288 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_262145_524288(self):
    self.__tx_262145_524288 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-262145-524288", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_524289_1048576(self):
    """
    Getter method for tx_524289_1048576, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_524289_1048576 (oc-yang:counter64)

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    return self.__tx_524289_1048576
      
  def _set_tx_524289_1048576(self, v, load=False):
    """
    Setter method for tx_524289_1048576, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist/tx_524289_1048576 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_524289_1048576 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_524289_1048576() directly.

    YANG Description: Transmitted AMPDU from 524289 to 1048576 Bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_524289_1048576 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_524289_1048576 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_524289_1048576(self):
    self.__tx_524289_1048576 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-524289-1048576", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  tx_0_64 = __builtin__.property(_get_tx_0_64)
  tx_65_128 = __builtin__.property(_get_tx_65_128)
  tx_129_256 = __builtin__.property(_get_tx_129_256)
  tx_257_512 = __builtin__.property(_get_tx_257_512)
  tx_513_1024 = __builtin__.property(_get_tx_513_1024)
  tx_1025_2048 = __builtin__.property(_get_tx_1025_2048)
  tx_2049_4096 = __builtin__.property(_get_tx_2049_4096)
  tx_4097_8192 = __builtin__.property(_get_tx_4097_8192)
  tx_8193_16384 = __builtin__.property(_get_tx_8193_16384)
  tx_16385_32768 = __builtin__.property(_get_tx_16385_32768)
  tx_32769_65536 = __builtin__.property(_get_tx_32769_65536)
  tx_65537_131072 = __builtin__.property(_get_tx_65537_131072)
  tx_131073_262144 = __builtin__.property(_get_tx_131073_262144)
  tx_262145_524288 = __builtin__.property(_get_tx_262145_524288)
  tx_524289_1048576 = __builtin__.property(_get_tx_524289_1048576)


  _pyangbind_elements = {'tx_0_64': tx_0_64, 'tx_65_128': tx_65_128, 'tx_129_256': tx_129_256, 'tx_257_512': tx_257_512, 'tx_513_1024': tx_513_1024, 'tx_1025_2048': tx_1025_2048, 'tx_2049_4096': tx_2049_4096, 'tx_4097_8192': tx_4097_8192, 'tx_8193_16384': tx_8193_16384, 'tx_16385_32768': tx_16385_32768, 'tx_32769_65536': tx_32769_65536, 'tx_65537_131072': tx_65537_131072, 'tx_131073_262144': tx_131073_262144, 'tx_262145_524288': tx_262145_524288, 'tx_524289_1048576': tx_524289_1048576, }


class yc_tx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_wmm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters/tx-data-wmm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transmitted QoS Data frames, per WMM AC.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__vi','__vo','__bk','__be',)

  _yang_name = 'tx-data-wmm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters', u'tx-data-wmm']

  def _get_vi(self):
    """
    Getter method for vi, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/vi (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Video.
    """
    return self.__vi
      
  def _set_vi(self, v, load=False):
    """
    Setter method for vi, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/vi (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vi() directly.

    YANG Description: Tx Data frames marked as Access Category Video.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vi must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vi(self):
    self.__vi = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_vo(self):
    """
    Getter method for vo, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/vo (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Voice.
    """
    return self.__vo
      
  def _set_vo(self, v, load=False):
    """
    Setter method for vo, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/vo (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vo() directly.

    YANG Description: Tx Data frames marked as Access Category Voice.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vo must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__vo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vo(self):
    self.__vo = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="vo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_bk(self):
    """
    Getter method for bk, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/bk (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Background.
    """
    return self.__bk
      
  def _set_bk(self, v, load=False):
    """
    Setter method for bk, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/bk (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bk() directly.

    YANG Description: Tx Data frames marked as Access Category Background.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bk must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__bk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bk(self):
    self.__bk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_be(self):
    """
    Getter method for be, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/be (oc-yang:counter64)

    YANG Description: Tx Data frames marked as Access Category Best Effort.
    """
    return self.__be
      
  def _set_be(self, v, load=False):
    """
    Setter method for be, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm/be (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_be is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_be() directly.

    YANG Description: Tx Data frames marked as Access Category Best Effort.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """be must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__be = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_be(self):
    self.__be = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="be", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  vi = __builtin__.property(_get_vi)
  vo = __builtin__.property(_get_vo)
  bk = __builtin__.property(_get_bk)
  be = __builtin__.property(_get_be)


  _pyangbind_elements = {'vi': vi, 'vo': vo, 'bk': bk, 'be': be, }


class yc_tx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_tx_mcs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters/tx-mcs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transmitted Data frames, per MCS Index. It is expected that vendors
bucketize 802.11n MCS frames in their matching 802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mcs0','__mcs1','__mcs2','__mcs3','__mcs4','__mcs5','__mcs6','__mcs7','__mcs8','__mcs9',)

  _yang_name = 'tx-mcs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters', u'tx-mcs']

  def _get_mcs0(self):
    """
    Getter method for mcs0, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs0 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 0.
    """
    return self.__mcs0
      
  def _set_mcs0(self, v, load=False):
    """
    Setter method for mcs0, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs0 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs0 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs0() directly.

    YANG Description: Tx Data frames at MCS 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs0 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs0 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs0(self):
    self.__mcs0 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs0", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs1(self):
    """
    Getter method for mcs1, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs1 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 1.
    """
    return self.__mcs1
      
  def _set_mcs1(self, v, load=False):
    """
    Setter method for mcs1, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs1 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs1() directly.

    YANG Description: Tx Data frames at MCS 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs1 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs1(self):
    self.__mcs1 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs2(self):
    """
    Getter method for mcs2, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs2 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 2.
    """
    return self.__mcs2
      
  def _set_mcs2(self, v, load=False):
    """
    Setter method for mcs2, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs2 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs2() directly.

    YANG Description: Tx Data frames at MCS 2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs2 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs2(self):
    self.__mcs2 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs3(self):
    """
    Getter method for mcs3, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs3 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 3.
    """
    return self.__mcs3
      
  def _set_mcs3(self, v, load=False):
    """
    Setter method for mcs3, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs3 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs3 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs3() directly.

    YANG Description: Tx Data frames at MCS 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs3 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs3 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs3(self):
    self.__mcs3 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs3", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs4(self):
    """
    Getter method for mcs4, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs4 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 4.
    """
    return self.__mcs4
      
  def _set_mcs4(self, v, load=False):
    """
    Setter method for mcs4, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs4 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs4() directly.

    YANG Description: Tx Data frames at MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs4 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs4(self):
    self.__mcs4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs5(self):
    """
    Getter method for mcs5, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs5 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 5.
    """
    return self.__mcs5
      
  def _set_mcs5(self, v, load=False):
    """
    Setter method for mcs5, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs5 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs5() directly.

    YANG Description: Tx Data frames at MCS 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs5 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs5(self):
    self.__mcs5 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs6(self):
    """
    Getter method for mcs6, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs6 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 6.
    """
    return self.__mcs6
      
  def _set_mcs6(self, v, load=False):
    """
    Setter method for mcs6, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs6 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs6() directly.

    YANG Description: Tx Data frames at MCS 6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs6 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs6(self):
    self.__mcs6 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs7(self):
    """
    Getter method for mcs7, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs7 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 7.
    """
    return self.__mcs7
      
  def _set_mcs7(self, v, load=False):
    """
    Setter method for mcs7, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs7 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs7() directly.

    YANG Description: Tx Data frames at MCS 7.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs7 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs7(self):
    self.__mcs7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs8(self):
    """
    Getter method for mcs8, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs8 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 8.
    """
    return self.__mcs8
      
  def _set_mcs8(self, v, load=False):
    """
    Setter method for mcs8, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs8 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs8 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs8() directly.

    YANG Description: Tx Data frames at MCS 8.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs8 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs8 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs8(self):
    self.__mcs8 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs8", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_mcs9(self):
    """
    Getter method for mcs9, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs9 (oc-yang:counter64)

    YANG Description: Tx Data frames at MCS 9.
    """
    return self.__mcs9
      
  def _set_mcs9(self, v, load=False):
    """
    Setter method for mcs9, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs/mcs9 (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mcs9 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mcs9() directly.

    YANG Description: Tx Data frames at MCS 9.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mcs9 must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__mcs9 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mcs9(self):
    self.__mcs9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mcs9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  mcs0 = __builtin__.property(_get_mcs0)
  mcs1 = __builtin__.property(_get_mcs1)
  mcs2 = __builtin__.property(_get_mcs2)
  mcs3 = __builtin__.property(_get_mcs3)
  mcs4 = __builtin__.property(_get_mcs4)
  mcs5 = __builtin__.property(_get_mcs5)
  mcs6 = __builtin__.property(_get_mcs6)
  mcs7 = __builtin__.property(_get_mcs7)
  mcs8 = __builtin__.property(_get_mcs8)
  mcs9 = __builtin__.property(_get_mcs9)


  _pyangbind_elements = {'mcs0': mcs0, 'mcs1': mcs1, 'mcs2': mcs2, 'mcs3': mcs3, 'mcs4': mcs4, 'mcs5': mcs5, 'mcs6': mcs6, 'mcs7': mcs7, 'mcs8': mcs8, 'mcs9': mcs9, }


class yc_counters_openconfig_wifi_mac__ssids_ssid_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of 802.11-related statistics.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__rx_mgmt','__rx_control','__rx_data_dist','__rx_data_wmm','__rx_mcs','__rx_retries','__rx_retries_data','__rx_retries_subframe','__rx_bytes_data','__tx_mgmt','__tx_control','__tx_data_dist','__tx_data_wmm','__tx_mcs','__tx_retries','__tx_retries_data','__tx_retries_subframe','__tx_bytes_data','__num_associated_clients',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_data_dist = YANGDynClass(base=yc_rx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_mcs = YANGDynClass(base=yc_tx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__rx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_mcs = YANGDynClass(base=yc_rx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__tx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__num_associated_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__tx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_data_wmm = YANGDynClass(base=yc_tx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__rx_data_wmm = YANGDynClass(base=yc_rx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_data_dist = YANGDynClass(base=yc_tx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__rx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state', u'counters']

  def _get_rx_mgmt(self):
    """
    Getter method for rx_mgmt, mapped from YANG variable /ssids/ssid/state/counters/rx_mgmt (oc-yang:counter64)

    YANG Description: Received 802.11 Management frames.
    """
    return self.__rx_mgmt
      
  def _set_rx_mgmt(self, v, load=False):
    """
    Setter method for rx_mgmt, mapped from YANG variable /ssids/ssid/state/counters/rx_mgmt (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_mgmt() directly.

    YANG Description: Received 802.11 Management frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_mgmt must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_mgmt(self):
    self.__rx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_control(self):
    """
    Getter method for rx_control, mapped from YANG variable /ssids/ssid/state/counters/rx_control (oc-yang:counter64)

    YANG Description: Received 802.11 Control frames.
    """
    return self.__rx_control
      
  def _set_rx_control(self, v, load=False):
    """
    Setter method for rx_control, mapped from YANG variable /ssids/ssid/state/counters/rx_control (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_control() directly.

    YANG Description: Received 802.11 Control frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_control must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_control(self):
    self.__rx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_data_dist(self):
    """
    Getter method for rx_data_dist, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist (container)

    YANG Description: The distribution of Data frame sizes in bytes of successfully recieved
AMPDU, or MPDU for non-aggregated, frames.
The distribution should characterize frame sizes starting at 64 bytes
or less with the bin size doubling for each successive bin to a
maximum of 1MB or larger, as represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    return self.__rx_data_dist
      
  def _set_rx_data_dist(self, v, load=False):
    """
    Setter method for rx_data_dist, mapped from YANG variable /ssids/ssid/state/counters/rx_data_dist (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_data_dist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_data_dist() directly.

    YANG Description: The distribution of Data frame sizes in bytes of successfully recieved
AMPDU, or MPDU for non-aggregated, frames.
The distribution should characterize frame sizes starting at 64 bytes
or less with the bin size doubling for each successive bin to a
maximum of 1MB or larger, as represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_data_dist must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__rx_data_dist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_data_dist(self):
    self.__rx_data_dist = YANGDynClass(base=yc_rx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_dist, is_container='container', yang_name="rx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_rx_data_wmm(self):
    """
    Getter method for rx_data_wmm, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm (container)

    YANG Description: Received 802.11 Data frames, per WMM Access Category.
    """
    return self.__rx_data_wmm
      
  def _set_rx_data_wmm(self, v, load=False):
    """
    Setter method for rx_data_wmm, mapped from YANG variable /ssids/ssid/state/counters/rx_data_wmm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_data_wmm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_data_wmm() directly.

    YANG Description: Received 802.11 Data frames, per WMM Access Category.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_data_wmm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__rx_data_wmm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_data_wmm(self):
    self.__rx_data_wmm = YANGDynClass(base=yc_rx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_rx_data_wmm, is_container='container', yang_name="rx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_rx_mcs(self):
    """
    Getter method for rx_mcs, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs (container)

    YANG Description: Received Data frames, per MCS Index. It is expected that vendors
bucketize 802.11n MCS frames in their matching 802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    return self.__rx_mcs
      
  def _set_rx_mcs(self, v, load=False):
    """
    Setter method for rx_mcs, mapped from YANG variable /ssids/ssid/state/counters/rx_mcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_mcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_mcs() directly.

    YANG Description: Received Data frames, per MCS Index. It is expected that vendors
bucketize 802.11n MCS frames in their matching 802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_mcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__rx_mcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_mcs(self):
    self.__rx_mcs = YANGDynClass(base=yc_rx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_rx_mcs, is_container='container', yang_name="rx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_rx_retries(self):
    """
    Getter method for rx_retries, mapped from YANG variable /ssids/ssid/state/counters/rx_retries (oc-yang:counter64)

    YANG Description: Total number of received frames with the Retry bit set, within this
BSS.
    """
    return self.__rx_retries
      
  def _set_rx_retries(self, v, load=False):
    """
    Setter method for rx_retries, mapped from YANG variable /ssids/ssid/state/counters/rx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries() directly.

    YANG Description: Total number of received frames with the Retry bit set, within this
BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries(self):
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_retries_data(self):
    """
    Getter method for rx_retries_data, mapped from YANG variable /ssids/ssid/state/counters/rx_retries_data (oc-yang:counter64)

    YANG Description: Number of received QoS Data frames with the Retry bit set
    """
    return self.__rx_retries_data
      
  def _set_rx_retries_data(self, v, load=False):
    """
    Setter method for rx_retries_data, mapped from YANG variable /ssids/ssid/state/counters/rx_retries_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries_data() directly.

    YANG Description: Number of received QoS Data frames with the Retry bit set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries_data(self):
    self.__rx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_retries_subframe(self):
    """
    Getter method for rx_retries_subframe, mapped from YANG variable /ssids/ssid/state/counters/rx_retries_subframe (oc-yang:counter64)

    YANG Description: Aggregated MPDUs which had individual subframes that fail and require
retransmission.
    """
    return self.__rx_retries_subframe
      
  def _set_rx_retries_subframe(self, v, load=False):
    """
    Setter method for rx_retries_subframe, mapped from YANG variable /ssids/ssid/state/counters/rx_retries_subframe (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries_subframe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries_subframe() directly.

    YANG Description: Aggregated MPDUs which had individual subframes that fail and require
retransmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries_subframe must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries_subframe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries_subframe(self):
    self.__rx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_bytes_data(self):
    """
    Getter method for rx_bytes_data, mapped from YANG variable /ssids/ssid/state/counters/rx_bytes_data (oc-yang:counter64)

    YANG Description: Bytes received from QoS Data frames
    """
    return self.__rx_bytes_data
      
  def _set_rx_bytes_data(self, v, load=False):
    """
    Setter method for rx_bytes_data, mapped from YANG variable /ssids/ssid/state/counters/rx_bytes_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_bytes_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_bytes_data() directly.

    YANG Description: Bytes received from QoS Data frames
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_bytes_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_bytes_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_bytes_data(self):
    self.__rx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_mgmt(self):
    """
    Getter method for tx_mgmt, mapped from YANG variable /ssids/ssid/state/counters/tx_mgmt (oc-yang:counter64)

    YANG Description: Transmitted 802.11 Management frames.
    """
    return self.__tx_mgmt
      
  def _set_tx_mgmt(self, v, load=False):
    """
    Setter method for tx_mgmt, mapped from YANG variable /ssids/ssid/state/counters/tx_mgmt (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_mgmt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_mgmt() directly.

    YANG Description: Transmitted 802.11 Management frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_mgmt must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_mgmt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_mgmt(self):
    self.__tx_mgmt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-mgmt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_control(self):
    """
    Getter method for tx_control, mapped from YANG variable /ssids/ssid/state/counters/tx_control (oc-yang:counter64)

    YANG Description: Transmitted 802.11 Control frames.
    """
    return self.__tx_control
      
  def _set_tx_control(self, v, load=False):
    """
    Setter method for tx_control, mapped from YANG variable /ssids/ssid/state/counters/tx_control (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_control() directly.

    YANG Description: Transmitted 802.11 Control frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_control must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_control(self):
    self.__tx_control = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_data_dist(self):
    """
    Getter method for tx_data_dist, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist (container)

    YANG Description: The distribution of Data frame sizes in bytes of successfully transmitted
AMPDU, or MPDU for non-aggregated, frames.
The distribution should characterize frame sizes starting at 64 bytes
or less with the bin size doubling for each successive bin to a
maximum of 1MB or larger, as represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    return self.__tx_data_dist
      
  def _set_tx_data_dist(self, v, load=False):
    """
    Setter method for tx_data_dist, mapped from YANG variable /ssids/ssid/state/counters/tx_data_dist (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_data_dist is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_data_dist() directly.

    YANG Description: The distribution of Data frame sizes in bytes of successfully transmitted
AMPDU, or MPDU for non-aggregated, frames.
The distribution should characterize frame sizes starting at 64 bytes
or less with the bin size doubling for each successive bin to a
maximum of 1MB or larger, as represented in the following table:

Lower Bound Upper Bound
  0          64
  65         128
  129        256
  257        512
  513        1024
  1025       2048
  2049       4096
  4097       8192
  8193       16384
  16385      32768
  32769      65536
  65537      131072
  131073     262144
  262145     524288
  524289     1048576
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_data_dist must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__tx_data_dist = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_data_dist(self):
    self.__tx_data_dist = YANGDynClass(base=yc_tx_data_dist_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_dist, is_container='container', yang_name="tx-data-dist", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_tx_data_wmm(self):
    """
    Getter method for tx_data_wmm, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm (container)

    YANG Description: Transmitted QoS Data frames, per WMM AC.
    """
    return self.__tx_data_wmm
      
  def _set_tx_data_wmm(self, v, load=False):
    """
    Setter method for tx_data_wmm, mapped from YANG variable /ssids/ssid/state/counters/tx_data_wmm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_data_wmm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_data_wmm() directly.

    YANG Description: Transmitted QoS Data frames, per WMM AC.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_data_wmm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__tx_data_wmm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_data_wmm(self):
    self.__tx_data_wmm = YANGDynClass(base=yc_tx_data_wmm_openconfig_wifi_mac__ssids_ssid_state_counters_tx_data_wmm, is_container='container', yang_name="tx-data-wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_tx_mcs(self):
    """
    Getter method for tx_mcs, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs (container)

    YANG Description: Transmitted Data frames, per MCS Index. It is expected that vendors
bucketize 802.11n MCS frames in their matching 802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    return self.__tx_mcs
      
  def _set_tx_mcs(self, v, load=False):
    """
    Setter method for tx_mcs, mapped from YANG variable /ssids/ssid/state/counters/tx_mcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_mcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_mcs() directly.

    YANG Description: Transmitted Data frames, per MCS Index. It is expected that vendors
bucketize 802.11n MCS frames in their matching 802.11ac buckets.

Example, 802.11n MCS 15 = 802.11ac MCS 7.
802.11n MCS 20 = 802.11ac MCS 4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_mcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__tx_mcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_mcs(self):
    self.__tx_mcs = YANGDynClass(base=yc_tx_mcs_openconfig_wifi_mac__ssids_ssid_state_counters_tx_mcs, is_container='container', yang_name="tx-mcs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_tx_retries(self):
    """
    Getter method for tx_retries, mapped from YANG variable /ssids/ssid/state/counters/tx_retries (oc-yang:counter64)

    YANG Description: Number of frames transmitted with the Retry bit set
    """
    return self.__tx_retries
      
  def _set_tx_retries(self, v, load=False):
    """
    Setter method for tx_retries, mapped from YANG variable /ssids/ssid/state/counters/tx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries() directly.

    YANG Description: Number of frames transmitted with the Retry bit set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries(self):
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_retries_data(self):
    """
    Getter method for tx_retries_data, mapped from YANG variable /ssids/ssid/state/counters/tx_retries_data (oc-yang:counter64)

    YANG Description: Number of transmitted QoS Data frames with the Retry bit set
    """
    return self.__tx_retries_data
      
  def _set_tx_retries_data(self, v, load=False):
    """
    Setter method for tx_retries_data, mapped from YANG variable /ssids/ssid/state/counters/tx_retries_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries_data() directly.

    YANG Description: Number of transmitted QoS Data frames with the Retry bit set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries_data(self):
    self.__tx_retries_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_retries_subframe(self):
    """
    Getter method for tx_retries_subframe, mapped from YANG variable /ssids/ssid/state/counters/tx_retries_subframe (oc-yang:counter64)

    YANG Description: Aggregated MPDUs which had individual subframes that fail and require
retransmission.
    """
    return self.__tx_retries_subframe
      
  def _set_tx_retries_subframe(self, v, load=False):
    """
    Setter method for tx_retries_subframe, mapped from YANG variable /ssids/ssid/state/counters/tx_retries_subframe (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries_subframe is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries_subframe() directly.

    YANG Description: Aggregated MPDUs which had individual subframes that fail and require
retransmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries_subframe must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries_subframe = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries_subframe(self):
    self.__tx_retries_subframe = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries-subframe", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_bytes_data(self):
    """
    Getter method for tx_bytes_data, mapped from YANG variable /ssids/ssid/state/counters/tx_bytes_data (oc-yang:counter64)

    YANG Description: Bytes transmitted from QoS Data frames
    """
    return self.__tx_bytes_data
      
  def _set_tx_bytes_data(self, v, load=False):
    """
    Setter method for tx_bytes_data, mapped from YANG variable /ssids/ssid/state/counters/tx_bytes_data (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_bytes_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_bytes_data() directly.

    YANG Description: Bytes transmitted from QoS Data frames
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_bytes_data must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_bytes_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_bytes_data(self):
    self.__tx_bytes_data = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_num_associated_clients(self):
    """
    Getter method for num_associated_clients, mapped from YANG variable /ssids/ssid/state/counters/num_associated_clients (uint8)

    YANG Description: Number of associated STAs to this BSS.
    """
    return self.__num_associated_clients
      
  def _set_num_associated_clients(self, v, load=False):
    """
    Setter method for num_associated_clients, mapped from YANG variable /ssids/ssid/state/counters/num_associated_clients (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_associated_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_associated_clients() directly.

    YANG Description: Number of associated STAs to this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_associated_clients must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__num_associated_clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_associated_clients(self):
    self.__num_associated_clients = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-associated-clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

  rx_mgmt = __builtin__.property(_get_rx_mgmt)
  rx_control = __builtin__.property(_get_rx_control)
  rx_data_dist = __builtin__.property(_get_rx_data_dist)
  rx_data_wmm = __builtin__.property(_get_rx_data_wmm)
  rx_mcs = __builtin__.property(_get_rx_mcs)
  rx_retries = __builtin__.property(_get_rx_retries)
  rx_retries_data = __builtin__.property(_get_rx_retries_data)
  rx_retries_subframe = __builtin__.property(_get_rx_retries_subframe)
  rx_bytes_data = __builtin__.property(_get_rx_bytes_data)
  tx_mgmt = __builtin__.property(_get_tx_mgmt)
  tx_control = __builtin__.property(_get_tx_control)
  tx_data_dist = __builtin__.property(_get_tx_data_dist)
  tx_data_wmm = __builtin__.property(_get_tx_data_wmm)
  tx_mcs = __builtin__.property(_get_tx_mcs)
  tx_retries = __builtin__.property(_get_tx_retries)
  tx_retries_data = __builtin__.property(_get_tx_retries_data)
  tx_retries_subframe = __builtin__.property(_get_tx_retries_subframe)
  tx_bytes_data = __builtin__.property(_get_tx_bytes_data)
  num_associated_clients = __builtin__.property(_get_num_associated_clients)


  _pyangbind_elements = {'rx_mgmt': rx_mgmt, 'rx_control': rx_control, 'rx_data_dist': rx_data_dist, 'rx_data_wmm': rx_data_wmm, 'rx_mcs': rx_mcs, 'rx_retries': rx_retries, 'rx_retries_data': rx_retries_data, 'rx_retries_subframe': rx_retries_subframe, 'rx_bytes_data': rx_bytes_data, 'tx_mgmt': tx_mgmt, 'tx_control': tx_control, 'tx_data_dist': tx_data_dist, 'tx_data_wmm': tx_data_wmm, 'tx_mcs': tx_mcs, 'tx_retries': tx_retries, 'tx_retries_data': tx_retries_data, 'tx_retries_subframe': tx_retries_subframe, 'tx_bytes_data': tx_bytes_data, 'num_associated_clients': num_associated_clients, }


class yc_state_openconfig_wifi_mac__ssids_ssid_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data at the ssid level
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__enabled','__hidden','__vlan_id','__operating_frequency','__basic_data_rates','__supported_data_rates','__broadcast_filter','__multicast_filter','__ipv6_ndp_filter','__ipv6_ndp_filter_timer','__station_isolation','__opmode','__wpa2_psk','__server_group','__dva','__dhcp_required','__qbss_load','__advertise_apname','__csa','__ptk_timeout','__gtk_timeout','__dot11k','__okc','__bssid','__bss_channel_utilization','__rx_bss_dot11_channel_utilization','__tx_bss_dot11_channel_utilization','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    self.__bssid = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__server_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=False)
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__basic_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__supported_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_wifi_mac__ssids_ssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__tx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)
    self.__rx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__bss_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ssids/ssid/state/name (string)

    YANG Description: The name of the SSID.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ssids/ssid/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /ssids/ssid/state/enabled (boolean)

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /ssids/ssid/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: The desired operational state (up/down) of this SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /ssids/ssid/state/hidden (boolean)

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /ssids/ssid/state/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: Whether this SSID IE is hidden within Beacons.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_vlan_id(self):
    """
    Getter method for vlan_id, mapped from YANG variable /ssids/ssid/state/vlan_id (oc-vlan-types:vlan-id)

    YANG Description: Optional VLAN tag used by the SSID. When unspecified, defaults
to untagged.
    """
    return self.__vlan_id
      
  def _set_vlan_id(self, v, load=False):
    """
    Setter method for vlan_id, mapped from YANG variable /ssids/ssid/state/vlan_id (oc-vlan-types:vlan-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_id() directly.

    YANG Description: Optional VLAN tag used by the SSID. When unspecified, defaults
to untagged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_id must be of a type compatible with oc-vlan-types:vlan-id""",
          'defined-type': "oc-vlan-types:vlan-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=False)""",
        })

    self.__vlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_id(self):
    self.__vlan_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..4094']}), is_leaf=True, yang_name="vlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-vlan-types:vlan-id', is_config=False)


  def _get_operating_frequency(self):
    """
    Getter method for operating_frequency, mapped from YANG variable /ssids/ssid/state/operating_frequency (identityref)

    YANG Description: Operating frequency of this SSID. When none specified, the default is
dual-band.
    """
    return self.__operating_frequency
      
  def _set_operating_frequency(self, v, load=False):
    """
    Setter method for operating_frequency, mapped from YANG variable /ssids/ssid/state/operating_frequency (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_frequency() directly.

    YANG Description: Operating frequency of this SSID. When none specified, the default is
dual-band.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_frequency must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)""",
        })

    self.__operating_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_frequency(self):
    self.__operating_frequency = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_5GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2_5_GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'FREQ_2GHZ': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), default=unicode("oc-wifi-types:FREQ_2_5_GHZ"), is_leaf=True, yang_name="operating-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)


  def _get_basic_data_rates(self):
    """
    Getter method for basic_data_rates, mapped from YANG variable /ssids/ssid/state/basic_data_rates (identityref)

    YANG Description: Basic data-rates for the SSID.
    """
    return self.__basic_data_rates
      
  def _set_basic_data_rates(self, v, load=False):
    """
    Setter method for basic_data_rates, mapped from YANG variable /ssids/ssid/state/basic_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_basic_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_basic_data_rates() directly.

    YANG Description: Basic data-rates for the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """basic_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)""",
        })

    self.__basic_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_basic_data_rates(self):
    self.__basic_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="basic-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)


  def _get_supported_data_rates(self):
    """
    Getter method for supported_data_rates, mapped from YANG variable /ssids/ssid/state/supported_data_rates (identityref)

    YANG Description: Supported data-rates for the SSID.
    """
    return self.__supported_data_rates
      
  def _set_supported_data_rates(self, v, load=False):
    """
    Setter method for supported_data_rates, mapped from YANG variable /ssids/ssid/state/supported_data_rates (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_data_rates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_data_rates() directly.

    YANG Description: Supported data-rates for the SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_data_rates must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)""",
        })

    self.__supported_data_rates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_data_rates(self):
    self.__supported_data_rates = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_11MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_12MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_6MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_1MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_54MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_24MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_36MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_9MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_5.5MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_2MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'RATE_48MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:RATE_18MB': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="supported-data-rates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)


  def _get_broadcast_filter(self):
    """
    Getter method for broadcast_filter, mapped from YANG variable /ssids/ssid/state/broadcast_filter (boolean)

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    return self.__broadcast_filter
      
  def _set_broadcast_filter(self, v, load=False):
    """
    Setter method for broadcast_filter, mapped from YANG variable /ssids/ssid/state/broadcast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_broadcast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_broadcast_filter() directly.

    YANG Description: Convert all downstream broadcast ARP to unicast
only if Station is associated to the AP. Drop packet
if Station is not associated to the AP. All other
broadcast, except DHCP, is dropped by the AP.

DHCP Offers/ACKs are converted to Unicast, over-the-air.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """broadcast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__broadcast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_broadcast_filter(self):
    self.__broadcast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_multicast_filter(self):
    """
    Getter method for multicast_filter, mapped from YANG variable /ssids/ssid/state/multicast_filter (boolean)

    YANG Description: Drop all downstream Multicast packets.
    """
    return self.__multicast_filter
      
  def _set_multicast_filter(self, v, load=False):
    """
    Setter method for multicast_filter, mapped from YANG variable /ssids/ssid/state/multicast_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicast_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicast_filter() directly.

    YANG Description: Drop all downstream Multicast packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multicast_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__multicast_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicast_filter(self):
    self.__multicast_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multicast-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_ipv6_ndp_filter(self):
    """
    Getter method for ipv6_ndp_filter, mapped from YANG variable /ssids/ssid/state/ipv6_ndp_filter (boolean)

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    return self.__ipv6_ndp_filter
      
  def _set_ipv6_ndp_filter(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter, mapped from YANG variable /ssids/ssid/state/ipv6_ndp_filter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter() directly.

    YANG Description: Neighbor Advertisements will be cached at the AP (or WLC)
and unicast in response to Neighbor Solicitations.

Router Advertisements, in response to a Router Solicitation
are converted to Unicast for over-the-air transmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__ipv6_ndp_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter(self):
    self.__ipv6_ndp_filter = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipv6-ndp-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_ipv6_ndp_filter_timer(self):
    """
    Getter method for ipv6_ndp_filter_timer, mapped from YANG variable /ssids/ssid/state/ipv6_ndp_filter_timer (uint16)

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    return self.__ipv6_ndp_filter_timer
      
  def _set_ipv6_ndp_filter_timer(self, v, load=False):
    """
    Setter method for ipv6_ndp_filter_timer, mapped from YANG variable /ssids/ssid/state/ipv6_ndp_filter_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_ndp_filter_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_ndp_filter_timer() directly.

    YANG Description: Time, in seconds, the ndp-filter will cache
Neighbor Advertisements (NA).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_ndp_filter_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__ipv6_ndp_filter_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_ndp_filter_timer(self):
    self.__ipv6_ndp_filter_timer = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ipv6-ndp-filter-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_station_isolation(self):
    """
    Getter method for station_isolation, mapped from YANG variable /ssids/ssid/state/station_isolation (boolean)

    YANG Description: Block Station peer to peer communication.
    """
    return self.__station_isolation
      
  def _set_station_isolation(self, v, load=False):
    """
    Setter method for station_isolation, mapped from YANG variable /ssids/ssid/state/station_isolation (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_station_isolation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_station_isolation() directly.

    YANG Description: Block Station peer to peer communication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """station_isolation must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__station_isolation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_station_isolation(self):
    self.__station_isolation = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="station-isolation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_opmode(self):
    """
    Getter method for opmode, mapped from YANG variable /ssids/ssid/state/opmode (enumeration)

    YANG Description: The type of Layer2 authentication in use.
    """
    return self.__opmode
      
  def _set_opmode(self, v, load=False):
    """
    Setter method for opmode, mapped from YANG variable /ssids/ssid/state/opmode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opmode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opmode() directly.

    YANG Description: The type of Layer2 authentication in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opmode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wifi-mac:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)""",
        })

    self.__opmode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opmode(self):
    self.__opmode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'WPA2_ENTERPRISE': {}, u'WPA2_PERSONAL': {}, u'OPEN': {}},), default=unicode("OPEN"), is_leaf=True, yang_name="opmode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)


  def _get_wpa2_psk(self):
    """
    Getter method for wpa2_psk, mapped from YANG variable /ssids/ssid/state/wpa2_psk (string)

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    return self.__wpa2_psk
      
  def _set_wpa2_psk(self, v, load=False):
    """
    Setter method for wpa2_psk, mapped from YANG variable /ssids/ssid/state/wpa2_psk (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wpa2_psk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wpa2_psk() directly.

    YANG Description: The passphrase used on this WPA2-Personal SSID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wpa2_psk must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)""",
        })

    self.__wpa2_psk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wpa2_psk(self):
    self.__wpa2_psk = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'8..63']}), is_leaf=True, yang_name="wpa2-psk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)


  def _get_server_group(self):
    """
    Getter method for server_group, mapped from YANG variable /ssids/ssid/state/server_group (string)

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    return self.__server_group
      
  def _set_server_group(self, v, load=False):
    """
    Setter method for server_group, mapped from YANG variable /ssids/ssid/state/server_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_group() directly.

    YANG Description: Specifies the RADIUS server-group to be used,
as defined in the openconfig-aaa.yang model.

Including WPA2_PERSONAL as it can be accompained by MAB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)""",
        })

    self.__server_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_group(self):
    self.__server_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="server-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)


  def _get_dva(self):
    """
    Getter method for dva, mapped from YANG variable /ssids/ssid/state/dva (boolean)

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    return self.__dva
      
  def _set_dva(self, v, load=False):
    """
    Setter method for dva, mapped from YANG variable /ssids/ssid/state/dva (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dva is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dva() directly.

    YANG Description: Enable/disable Dynamic VLAN Assignment,
using 'Tunnel-Private-Group-Id' RADIUS attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dva must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dva = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dva(self):
    self.__dva = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dva", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_dhcp_required(self):
    """
    Getter method for dhcp_required, mapped from YANG variable /ssids/ssid/state/dhcp_required (boolean)

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    return self.__dhcp_required
      
  def _set_dhcp_required(self, v, load=False):
    """
    Setter method for dhcp_required, mapped from YANG variable /ssids/ssid/state/dhcp_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_required() directly.

    YANG Description: Allow a Station to access the network only if
a DHCP exchange has occurred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_required must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dhcp_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_required(self):
    self.__dhcp_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_qbss_load(self):
    """
    Getter method for qbss_load, mapped from YANG variable /ssids/ssid/state/qbss_load (boolean)

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    return self.__qbss_load
      
  def _set_qbss_load(self, v, load=False):
    """
    Setter method for qbss_load, mapped from YANG variable /ssids/ssid/state/qbss_load (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qbss_load is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qbss_load() directly.

    YANG Description: Advertisement of the QBSS Load Information ELement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qbss_load must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__qbss_load = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qbss_load(self):
    self.__qbss_load = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="qbss-load", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_advertise_apname(self):
    """
    Getter method for advertise_apname, mapped from YANG variable /ssids/ssid/state/advertise_apname (boolean)

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    return self.__advertise_apname
      
  def _set_advertise_apname(self, v, load=False):
    """
    Setter method for advertise_apname, mapped from YANG variable /ssids/ssid/state/advertise_apname (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_apname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_apname() directly.

    YANG Description: Advertise the AP hostname in Beacon and Probe Resp. frames.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_apname must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__advertise_apname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_apname(self):
    self.__advertise_apname = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-apname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_csa(self):
    """
    Getter method for csa, mapped from YANG variable /ssids/ssid/state/csa (boolean)

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    return self.__csa
      
  def _set_csa(self, v, load=False):
    """
    Setter method for csa, mapped from YANG variable /ssids/ssid/state/csa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_csa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_csa() directly.

    YANG Description: Enable/Disable 802.11h channel-switch-announcement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """csa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__csa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_csa(self):
    self.__csa = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="csa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_ptk_timeout(self):
    """
    Getter method for ptk_timeout, mapped from YANG variable /ssids/ssid/state/ptk_timeout (uint16)

    YANG Description: Time, in seconds, for the Pairwise Transient Key to be timed out.
    """
    return self.__ptk_timeout
      
  def _set_ptk_timeout(self, v, load=False):
    """
    Setter method for ptk_timeout, mapped from YANG variable /ssids/ssid/state/ptk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptk_timeout() directly.

    YANG Description: Time, in seconds, for the Pairwise Transient Key to be timed out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__ptk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptk_timeout(self):
    self.__ptk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="ptk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_gtk_timeout(self):
    """
    Getter method for gtk_timeout, mapped from YANG variable /ssids/ssid/state/gtk_timeout (uint16)

    YANG Description: TTL for the Group Temporal Key.
    """
    return self.__gtk_timeout
      
  def _set_gtk_timeout(self, v, load=False):
    """
    Setter method for gtk_timeout, mapped from YANG variable /ssids/ssid/state/gtk_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gtk_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gtk_timeout() directly.

    YANG Description: TTL for the Group Temporal Key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gtk_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__gtk_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gtk_timeout(self):
    self.__gtk_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="gtk-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_dot11k(self):
    """
    Getter method for dot11k, mapped from YANG variable /ssids/ssid/state/dot11k (boolean)

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    return self.__dot11k
      
  def _set_dot11k(self, v, load=False):
    """
    Setter method for dot11k, mapped from YANG variable /ssids/ssid/state/dot11k (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11k is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11k() directly.

    YANG Description: 802.11k neighbor-list enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11k must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dot11k = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11k(self):
    self.__dot11k = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11k", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_okc(self):
    """
    Getter method for okc, mapped from YANG variable /ssids/ssid/state/okc (boolean)

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    return self.__okc
      
  def _set_okc(self, v, load=False):
    """
    Setter method for okc, mapped from YANG variable /ssids/ssid/state/okc (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_okc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_okc() directly.

    YANG Description: Enable/disable Opportunistic Key Caching.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """okc must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__okc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_okc(self):
    self.__okc = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="okc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_bssid(self):
    """
    Getter method for bssid, mapped from YANG variable /ssids/ssid/state/bssid (oc-yang:mac-address)

    YANG Description: Represents the BSSID. Typically this is base-radio mac +/- in last
octet; though not strictly required.
    """
    return self.__bssid
      
  def _set_bssid(self, v, load=False):
    """
    Setter method for bssid, mapped from YANG variable /ssids/ssid/state/bssid (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bssid() directly.

    YANG Description: Represents the BSSID. Typically this is base-radio mac +/- in last
octet; though not strictly required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bssid must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bssid(self):
    self.__bssid = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)


  def _get_bss_channel_utilization(self):
    """
    Getter method for bss_channel_utilization, mapped from YANG variable /ssids/ssid/state/bss_channel_utilization (oc-types:percentage)

    YANG Description: Total 802.11 channel utilization on this BSS. The total channel
utilization should include all time periods the AP spent actively
receiving and transmitting 802.11 frames on this BSS.
    """
    return self.__bss_channel_utilization
      
  def _set_bss_channel_utilization(self, v, load=False):
    """
    Setter method for bss_channel_utilization, mapped from YANG variable /ssids/ssid/state/bss_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bss_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bss_channel_utilization() directly.

    YANG Description: Total 802.11 channel utilization on this BSS. The total channel
utilization should include all time periods the AP spent actively
receiving and transmitting 802.11 frames on this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bss_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__bss_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bss_channel_utilization(self):
    self.__bss_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="bss-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)


  def _get_rx_bss_dot11_channel_utilization(self):
    """
    Getter method for rx_bss_dot11_channel_utilization, mapped from YANG variable /ssids/ssid/state/rx_bss_dot11_channel_utilization (oc-types:percentage)

    YANG Description: Rx channel utilization percent for this BSS.
    """
    return self.__rx_bss_dot11_channel_utilization
      
  def _set_rx_bss_dot11_channel_utilization(self, v, load=False):
    """
    Setter method for rx_bss_dot11_channel_utilization, mapped from YANG variable /ssids/ssid/state/rx_bss_dot11_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_bss_dot11_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_bss_dot11_channel_utilization() directly.

    YANG Description: Rx channel utilization percent for this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_bss_dot11_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__rx_bss_dot11_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_bss_dot11_channel_utilization(self):
    self.__rx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="rx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)


  def _get_tx_bss_dot11_channel_utilization(self):
    """
    Getter method for tx_bss_dot11_channel_utilization, mapped from YANG variable /ssids/ssid/state/tx_bss_dot11_channel_utilization (oc-types:percentage)

    YANG Description: Tx channel utilization percent for this BSS.
    """
    return self.__tx_bss_dot11_channel_utilization
      
  def _set_tx_bss_dot11_channel_utilization(self, v, load=False):
    """
    Setter method for tx_bss_dot11_channel_utilization, mapped from YANG variable /ssids/ssid/state/tx_bss_dot11_channel_utilization (oc-types:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_bss_dot11_channel_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_bss_dot11_channel_utilization() directly.

    YANG Description: Tx channel utilization percent for this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_bss_dot11_channel_utilization must be of a type compatible with oc-types:percentage""",
          'defined-type': "oc-types:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)""",
        })

    self.__tx_bss_dot11_channel_utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_bss_dot11_channel_utilization(self):
    self.__tx_bss_dot11_channel_utilization = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="tx-bss-dot11-channel-utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-types:percentage', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /ssids/ssid/state/counters (container)

    YANG Description: A collection of 802.11-related statistics.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /ssids/ssid/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: A collection of 802.11-related statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_wifi_mac__ssids_ssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_wifi_mac__ssids_ssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_wifi_mac__ssids_ssid_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  enabled = __builtin__.property(_get_enabled)
  hidden = __builtin__.property(_get_hidden)
  vlan_id = __builtin__.property(_get_vlan_id)
  operating_frequency = __builtin__.property(_get_operating_frequency)
  basic_data_rates = __builtin__.property(_get_basic_data_rates)
  supported_data_rates = __builtin__.property(_get_supported_data_rates)
  broadcast_filter = __builtin__.property(_get_broadcast_filter)
  multicast_filter = __builtin__.property(_get_multicast_filter)
  ipv6_ndp_filter = __builtin__.property(_get_ipv6_ndp_filter)
  ipv6_ndp_filter_timer = __builtin__.property(_get_ipv6_ndp_filter_timer)
  station_isolation = __builtin__.property(_get_station_isolation)
  opmode = __builtin__.property(_get_opmode)
  wpa2_psk = __builtin__.property(_get_wpa2_psk)
  server_group = __builtin__.property(_get_server_group)
  dva = __builtin__.property(_get_dva)
  dhcp_required = __builtin__.property(_get_dhcp_required)
  qbss_load = __builtin__.property(_get_qbss_load)
  advertise_apname = __builtin__.property(_get_advertise_apname)
  csa = __builtin__.property(_get_csa)
  ptk_timeout = __builtin__.property(_get_ptk_timeout)
  gtk_timeout = __builtin__.property(_get_gtk_timeout)
  dot11k = __builtin__.property(_get_dot11k)
  okc = __builtin__.property(_get_okc)
  bssid = __builtin__.property(_get_bssid)
  bss_channel_utilization = __builtin__.property(_get_bss_channel_utilization)
  rx_bss_dot11_channel_utilization = __builtin__.property(_get_rx_bss_dot11_channel_utilization)
  tx_bss_dot11_channel_utilization = __builtin__.property(_get_tx_bss_dot11_channel_utilization)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = {'name': name, 'enabled': enabled, 'hidden': hidden, 'vlan_id': vlan_id, 'operating_frequency': operating_frequency, 'basic_data_rates': basic_data_rates, 'supported_data_rates': supported_data_rates, 'broadcast_filter': broadcast_filter, 'multicast_filter': multicast_filter, 'ipv6_ndp_filter': ipv6_ndp_filter, 'ipv6_ndp_filter_timer': ipv6_ndp_filter_timer, 'station_isolation': station_isolation, 'opmode': opmode, 'wpa2_psk': wpa2_psk, 'server_group': server_group, 'dva': dva, 'dhcp_required': dhcp_required, 'qbss_load': qbss_load, 'advertise_apname': advertise_apname, 'csa': csa, 'ptk_timeout': ptk_timeout, 'gtk_timeout': gtk_timeout, 'dot11k': dot11k, 'okc': okc, 'bssid': bssid, 'bss_channel_utilization': bss_channel_utilization, 'rx_bss_dot11_channel_utilization': rx_bss_dot11_channel_utilization, 'tx_bss_dot11_channel_utilization': tx_bss_dot11_channel_utilization, 'counters': counters, }


class yc_config_openconfig_wifi_mac__ssids_ssid_wmm_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/wmm/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for WMM configuration elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__trust_dscp','__wmm_vo_remark','__wmm_vi_remark','__wmm_be_remark','__wmm_bk_remark',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wmm_vo_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    self.__wmm_vi_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__wmm_be_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    self.__wmm_bk_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'wmm', u'config']

  def _get_trust_dscp(self):
    """
    Getter method for trust_dscp, mapped from YANG variable /ssids/ssid/wmm/config/trust_dscp (boolean)

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    return self.__trust_dscp
      
  def _set_trust_dscp(self, v, load=False):
    """
    Setter method for trust_dscp, mapped from YANG variable /ssids/ssid/wmm/config/trust_dscp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trust_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trust_dscp() directly.

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trust_dscp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__trust_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trust_dscp(self):
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_wmm_vo_remark(self):
    """
    Getter method for wmm_vo_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_vo_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vo_remark
      
  def _set_wmm_vo_remark(self, v, load=False):
    """
    Setter method for wmm_vo_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_vo_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vo_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vo_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vo_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_vo_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vo_remark(self):
    self.__wmm_vo_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)


  def _get_wmm_vi_remark(self):
    """
    Getter method for wmm_vi_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_vi_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vi_remark
      
  def _set_wmm_vi_remark(self, v, load=False):
    """
    Setter method for wmm_vi_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_vi_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vi_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vi_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vi_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_vi_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vi_remark(self):
    self.__wmm_vi_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)


  def _get_wmm_be_remark(self):
    """
    Getter method for wmm_be_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_be_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_be_remark
      
  def _set_wmm_be_remark(self, v, load=False):
    """
    Setter method for wmm_be_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_be_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_be_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_be_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_be_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_be_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_be_remark(self):
    self.__wmm_be_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)


  def _get_wmm_bk_remark(self):
    """
    Getter method for wmm_bk_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_bk_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_bk_remark
      
  def _set_wmm_bk_remark(self, v, load=False):
    """
    Setter method for wmm_bk_remark, mapped from YANG variable /ssids/ssid/wmm/config/wmm_bk_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_bk_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_bk_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_bk_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)""",
        })

    self.__wmm_bk_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_bk_remark(self):
    self.__wmm_bk_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)

  trust_dscp = __builtin__.property(_get_trust_dscp, _set_trust_dscp)
  wmm_vo_remark = __builtin__.property(_get_wmm_vo_remark, _set_wmm_vo_remark)
  wmm_vi_remark = __builtin__.property(_get_wmm_vi_remark, _set_wmm_vi_remark)
  wmm_be_remark = __builtin__.property(_get_wmm_be_remark, _set_wmm_be_remark)
  wmm_bk_remark = __builtin__.property(_get_wmm_bk_remark, _set_wmm_bk_remark)


  _pyangbind_elements = {'trust_dscp': trust_dscp, 'wmm_vo_remark': wmm_vo_remark, 'wmm_vi_remark': wmm_vi_remark, 'wmm_be_remark': wmm_be_remark, 'wmm_bk_remark': wmm_bk_remark, }


class yc_state_openconfig_wifi_mac__ssids_ssid_wmm_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/wmm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for WMM state elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__trust_dscp','__wmm_vo_remark','__wmm_vi_remark','__wmm_be_remark','__wmm_bk_remark',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wmm_vo_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__wmm_vi_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__wmm_be_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__wmm_bk_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'wmm', u'state']

  def _get_trust_dscp(self):
    """
    Getter method for trust_dscp, mapped from YANG variable /ssids/ssid/wmm/state/trust_dscp (boolean)

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    return self.__trust_dscp
      
  def _set_trust_dscp(self, v, load=False):
    """
    Setter method for trust_dscp, mapped from YANG variable /ssids/ssid/wmm/state/trust_dscp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trust_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trust_dscp() directly.

    YANG Description: The AP should trust DSCP on 802.11 frames received
in this BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trust_dscp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__trust_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trust_dscp(self):
    self.__trust_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="trust-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_wmm_vo_remark(self):
    """
    Getter method for wmm_vo_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_vo_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vo_remark
      
  def _set_wmm_vo_remark(self, v, load=False):
    """
    Setter method for wmm_vo_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_vo_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vo_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vo_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VO. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vo_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_vo_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vo_remark(self):
    self.__wmm_vo_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vo-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_wmm_vi_remark(self):
    """
    Getter method for wmm_vi_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_vi_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_vi_remark
      
  def _set_wmm_vi_remark(self, v, load=False):
    """
    Setter method for wmm_vi_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_vi_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_vi_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_vi_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_VI. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_vi_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_vi_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_vi_remark(self):
    self.__wmm_vi_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-vi-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_wmm_be_remark(self):
    """
    Getter method for wmm_be_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_be_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_be_remark
      
  def _set_wmm_be_remark(self, v, load=False):
    """
    Setter method for wmm_be_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_be_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_be_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_be_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BE. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_be_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_be_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_be_remark(self):
    self.__wmm_be_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-be-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_wmm_bk_remark(self):
    """
    Getter method for wmm_bk_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_bk_remark (uint8)

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    return self.__wmm_bk_remark
      
  def _set_wmm_bk_remark(self, v, load=False):
    """
    Setter method for wmm_bk_remark, mapped from YANG variable /ssids/ssid/wmm/state/wmm_bk_remark (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm_bk_remark is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm_bk_remark() directly.

    YANG Description: Allowed DSCP markings for WMM AC_BK. Remark to lowest in this list
if DSCP marking falls outside of these allowed markings.

From 1 (min) to 8 (max) integers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm_bk_remark must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__wmm_bk_remark = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm_bk_remark(self):
    self.__wmm_bk_remark = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="wmm-bk-remark", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

  trust_dscp = __builtin__.property(_get_trust_dscp)
  wmm_vo_remark = __builtin__.property(_get_wmm_vo_remark)
  wmm_vi_remark = __builtin__.property(_get_wmm_vi_remark)
  wmm_be_remark = __builtin__.property(_get_wmm_be_remark)
  wmm_bk_remark = __builtin__.property(_get_wmm_bk_remark)


  _pyangbind_elements = {'trust_dscp': trust_dscp, 'wmm_vo_remark': wmm_vo_remark, 'wmm_vi_remark': wmm_vi_remark, 'wmm_be_remark': wmm_be_remark, 'wmm_bk_remark': wmm_bk_remark, }


class yc_wmm_openconfig_wifi_mac__ssids_ssid_wmm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/wmm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for WMM configuration and
state container.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'wmm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'wmm']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ssids/ssid/wmm/config (container)

    YANG Description: Container for WMM configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ssids/ssid/wmm/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for WMM configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wifi_mac__ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_wmm_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/wmm/state (container)

    YANG Description: Container for WMM state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/wmm/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for WMM state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_wmm_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_wifi_mac__ssids_ssid_dot11r_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot11r/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11r configuration elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__dot11r','__dot11r_domainid','__dot11r_method','__dot11r_r1key_timeout',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot11r', u'config']

  def _get_dot11r(self):
    """
    Getter method for dot11r, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r (boolean)

    YANG Description: Enable/disable 802.11r FT.
    """
    return self.__dot11r
      
  def _set_dot11r(self, v, load=False):
    """
    Setter method for dot11r, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r() directly.

    YANG Description: Enable/disable 802.11r FT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dot11r = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r(self):
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_dot11r_domainid(self):
    """
    Getter method for dot11r_domainid, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r_domainid (uint16)

    YANG Description: Mobility Domain ID.
    """
    return self.__dot11r_domainid
      
  def _set_dot11r_domainid(self, v, load=False):
    """
    Setter method for dot11r_domainid, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r_domainid (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_domainid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_domainid() directly.

    YANG Description: Mobility Domain ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_domainid must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__dot11r_domainid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_domainid(self):
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)


  def _get_dot11r_method(self):
    """
    Getter method for dot11r_method, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r_method (enumeration)

    YANG Description: The type of 802.11r FT in use.
    """
    return self.__dot11r_method
      
  def _set_dot11r_method(self, v, load=False):
    """
    Setter method for dot11r_method, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_method() directly.

    YANG Description: The type of 802.11r FT in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wifi-mac:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)""",
        })

    self.__dot11r_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_method(self):
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=True)


  def _get_dot11r_r1key_timeout(self):
    """
    Getter method for dot11r_r1key_timeout, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r_r1key_timeout (uint16)

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    return self.__dot11r_r1key_timeout
      
  def _set_dot11r_r1key_timeout(self, v, load=False):
    """
    Setter method for dot11r_r1key_timeout, mapped from YANG variable /ssids/ssid/dot11r/config/dot11r_r1key_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_r1key_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_r1key_timeout() directly.

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_r1key_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__dot11r_r1key_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_r1key_timeout(self):
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)

  dot11r = __builtin__.property(_get_dot11r, _set_dot11r)
  dot11r_domainid = __builtin__.property(_get_dot11r_domainid, _set_dot11r_domainid)
  dot11r_method = __builtin__.property(_get_dot11r_method, _set_dot11r_method)
  dot11r_r1key_timeout = __builtin__.property(_get_dot11r_r1key_timeout, _set_dot11r_r1key_timeout)


  _pyangbind_elements = {'dot11r': dot11r, 'dot11r_domainid': dot11r_domainid, 'dot11r_method': dot11r_method, 'dot11r_r1key_timeout': dot11r_r1key_timeout, }


class yc_state_openconfig_wifi_mac__ssids_ssid_dot11r_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot11r/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11r state elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__dot11r','__dot11r_domainid','__dot11r_method','__dot11r_r1key_timeout',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot11r', u'state']

  def _get_dot11r(self):
    """
    Getter method for dot11r, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r (boolean)

    YANG Description: Enable/disable 802.11r FT.
    """
    return self.__dot11r
      
  def _set_dot11r(self, v, load=False):
    """
    Setter method for dot11r, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r() directly.

    YANG Description: Enable/disable 802.11r FT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dot11r = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r(self):
    self.__dot11r = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_dot11r_domainid(self):
    """
    Getter method for dot11r_domainid, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r_domainid (uint16)

    YANG Description: Mobility Domain ID.
    """
    return self.__dot11r_domainid
      
  def _set_dot11r_domainid(self, v, load=False):
    """
    Setter method for dot11r_domainid, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r_domainid (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_domainid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_domainid() directly.

    YANG Description: Mobility Domain ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_domainid must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__dot11r_domainid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_domainid(self):
    self.__dot11r_domainid = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-domainid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_dot11r_method(self):
    """
    Getter method for dot11r_method, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r_method (enumeration)

    YANG Description: The type of 802.11r FT in use.
    """
    return self.__dot11r_method
      
  def _set_dot11r_method(self, v, load=False):
    """
    Setter method for dot11r_method, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_method() directly.

    YANG Description: The type of 802.11r FT in use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wifi-mac:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)""",
        })

    self.__dot11r_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_method(self):
    self.__dot11r_method = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ODS': {}, u'OVA': {}},), default=unicode("OVA"), is_leaf=True, yang_name="dot11r-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)


  def _get_dot11r_r1key_timeout(self):
    """
    Getter method for dot11r_r1key_timeout, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r_r1key_timeout (uint16)

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    return self.__dot11r_r1key_timeout
      
  def _set_dot11r_r1key_timeout(self, v, load=False):
    """
    Setter method for dot11r_r1key_timeout, mapped from YANG variable /ssids/ssid/dot11r/state/dot11r_r1key_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r_r1key_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r_r1key_timeout() directly.

    YANG Description: TTL for the Pairwise Master Key R1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r_r1key_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__dot11r_r1key_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r_r1key_timeout(self):
    self.__dot11r_r1key_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11r-r1key-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)

  dot11r = __builtin__.property(_get_dot11r)
  dot11r_domainid = __builtin__.property(_get_dot11r_domainid)
  dot11r_method = __builtin__.property(_get_dot11r_method)
  dot11r_r1key_timeout = __builtin__.property(_get_dot11r_r1key_timeout)


  _pyangbind_elements = {'dot11r': dot11r, 'dot11r_domainid': dot11r_domainid, 'dot11r_method': dot11r_method, 'dot11r_r1key_timeout': dot11r_r1key_timeout, }


class yc_dot11r_openconfig_wifi_mac__ssids_ssid_dot11r(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot11r. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for 802.11r configuration and
state container.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'dot11r'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot11r']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ssids/ssid/dot11r/config (container)

    YANG Description: Container for 802.11r configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ssids/ssid/dot11r/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for 802.11r configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11r_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/dot11r/state (container)

    YANG Description: Container for 802.11r state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/dot11r/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for 802.11r state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11r_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_wifi_mac__ssids_ssid_dot11v_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot11v/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11v configuration elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__dot11v_dms','__dot11v_bssidle','__dot11v_bssidle_timeout','__dot11v_bsstransition',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot11v', u'config']

  def _get_dot11v_dms(self):
    """
    Getter method for dot11v_dms, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_dms (boolean)

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    return self.__dot11v_dms
      
  def _set_dot11v_dms(self, v, load=False):
    """
    Setter method for dot11v_dms, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_dms (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_dms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_dms() directly.

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_dms must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dot11v_dms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_dms(self):
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_dot11v_bssidle(self):
    """
    Getter method for dot11v_bssidle, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_bssidle (boolean)

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    return self.__dot11v_bssidle
      
  def _set_dot11v_bssidle(self, v, load=False):
    """
    Setter method for dot11v_bssidle, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_bssidle (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle() directly.

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dot11v_bssidle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle(self):
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_dot11v_bssidle_timeout(self):
    """
    Getter method for dot11v_bssidle_timeout, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_bssidle_timeout (uint16)

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    return self.__dot11v_bssidle_timeout
      
  def _set_dot11v_bssidle_timeout(self, v, load=False):
    """
    Setter method for dot11v_bssidle_timeout, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_bssidle_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle_timeout() directly.

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__dot11v_bssidle_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle_timeout(self):
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)


  def _get_dot11v_bsstransition(self):
    """
    Getter method for dot11v_bsstransition, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_bsstransition (boolean)

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    return self.__dot11v_bsstransition
      
  def _set_dot11v_bsstransition(self, v, load=False):
    """
    Setter method for dot11v_bsstransition, mapped from YANG variable /ssids/ssid/dot11v/config/dot11v_bsstransition (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bsstransition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bsstransition() directly.

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bsstransition must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__dot11v_bsstransition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bsstransition(self):
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)

  dot11v_dms = __builtin__.property(_get_dot11v_dms, _set_dot11v_dms)
  dot11v_bssidle = __builtin__.property(_get_dot11v_bssidle, _set_dot11v_bssidle)
  dot11v_bssidle_timeout = __builtin__.property(_get_dot11v_bssidle_timeout, _set_dot11v_bssidle_timeout)
  dot11v_bsstransition = __builtin__.property(_get_dot11v_bsstransition, _set_dot11v_bsstransition)


  _pyangbind_elements = {'dot11v_dms': dot11v_dms, 'dot11v_bssidle': dot11v_bssidle, 'dot11v_bssidle_timeout': dot11v_bssidle_timeout, 'dot11v_bsstransition': dot11v_bsstransition, }


class yc_state_openconfig_wifi_mac__ssids_ssid_dot11v_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot11v/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for 802.11r state elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__dot11v_dms','__dot11v_bssidle','__dot11v_bssidle_timeout','__dot11v_bsstransition',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot11v', u'state']

  def _get_dot11v_dms(self):
    """
    Getter method for dot11v_dms, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_dms (boolean)

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    return self.__dot11v_dms
      
  def _set_dot11v_dms(self, v, load=False):
    """
    Setter method for dot11v_dms, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_dms (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_dms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_dms() directly.

    YANG Description: 802.11v Directed Multicast Service enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_dms must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dot11v_dms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_dms(self):
    self.__dot11v_dms = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-dms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_dot11v_bssidle(self):
    """
    Getter method for dot11v_bssidle, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_bssidle (boolean)

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    return self.__dot11v_bssidle
      
  def _set_dot11v_bssidle(self, v, load=False):
    """
    Setter method for dot11v_bssidle, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_bssidle (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle() directly.

    YANG Description: 802.11v BSS Max Idle enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dot11v_bssidle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle(self):
    self.__dot11v_bssidle = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bssidle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_dot11v_bssidle_timeout(self):
    """
    Getter method for dot11v_bssidle_timeout, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_bssidle_timeout (uint16)

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    return self.__dot11v_bssidle_timeout
      
  def _set_dot11v_bssidle_timeout(self, v, load=False):
    """
    Setter method for dot11v_bssidle_timeout, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_bssidle_timeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bssidle_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bssidle_timeout() directly.

    YANG Description: 802.11v BSS Max Idle timeout.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bssidle_timeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__dot11v_bssidle_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bssidle_timeout(self):
    self.__dot11v_bssidle_timeout = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="dot11v-bssidle-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_dot11v_bsstransition(self):
    """
    Getter method for dot11v_bsstransition, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_bsstransition (boolean)

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    return self.__dot11v_bsstransition
      
  def _set_dot11v_bsstransition(self, v, load=False):
    """
    Setter method for dot11v_bsstransition, mapped from YANG variable /ssids/ssid/dot11v/state/dot11v_bsstransition (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v_bsstransition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v_bsstransition() directly.

    YANG Description: 802.11v BSS Transition enabled/disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v_bsstransition must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__dot11v_bsstransition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v_bsstransition(self):
    self.__dot11v_bsstransition = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dot11v-bsstransition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)

  dot11v_dms = __builtin__.property(_get_dot11v_dms)
  dot11v_bssidle = __builtin__.property(_get_dot11v_bssidle)
  dot11v_bssidle_timeout = __builtin__.property(_get_dot11v_bssidle_timeout)
  dot11v_bsstransition = __builtin__.property(_get_dot11v_bsstransition)


  _pyangbind_elements = {'dot11v_dms': dot11v_dms, 'dot11v_bssidle': dot11v_bssidle, 'dot11v_bssidle_timeout': dot11v_bssidle_timeout, 'dot11v_bsstransition': dot11v_bsstransition, }


class yc_dot11v_openconfig_wifi_mac__ssids_ssid_dot11v(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot11v. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for 802.11v configuration and
operational state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'dot11v'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot11v']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ssids/ssid/dot11v/config (container)

    YANG Description: Container for 802.11v configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ssids/ssid/dot11v/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for 802.11v configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot11v_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/dot11v/state (container)

    YANG Description: Container for 802.11r state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/dot11v/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for 802.11r state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot11v_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_counters_openconfig_wifi_mac__ssids_ssid_clients_client_state_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-client counters.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__tx_bytes','__rx_bytes','__rx_retries','__tx_retries',)

  _yang_name = 'counters'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'state', u'counters']

  def _get_tx_bytes(self):
    """
    Getter method for tx_bytes, mapped from YANG variable /ssids/ssid/clients/client/state/counters/tx_bytes (oc-yang:counter64)

    YANG Description: Tx Bytes to this client.
    """
    return self.__tx_bytes
      
  def _set_tx_bytes(self, v, load=False):
    """
    Setter method for tx_bytes, mapped from YANG variable /ssids/ssid/clients/client/state/counters/tx_bytes (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_bytes() directly.

    YANG Description: Tx Bytes to this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_bytes must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_bytes(self):
    self.__tx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_bytes(self):
    """
    Getter method for rx_bytes, mapped from YANG variable /ssids/ssid/clients/client/state/counters/rx_bytes (oc-yang:counter64)

    YANG Description: Rx Bytes from this client.
    """
    return self.__rx_bytes
      
  def _set_rx_bytes(self, v, load=False):
    """
    Setter method for rx_bytes, mapped from YANG variable /ssids/ssid/clients/client/state/counters/rx_bytes (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_bytes() directly.

    YANG Description: Rx Bytes from this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_bytes must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_bytes(self):
    self.__rx_bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_rx_retries(self):
    """
    Getter method for rx_retries, mapped from YANG variable /ssids/ssid/clients/client/state/counters/rx_retries (oc-yang:counter64)

    YANG Description: Rx retried frames from this client.
    """
    return self.__rx_retries
      
  def _set_rx_retries(self, v, load=False):
    """
    Setter method for rx_retries, mapped from YANG variable /ssids/ssid/clients/client/state/counters/rx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rx_retries() directly.

    YANG Description: Rx retried frames from this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__rx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rx_retries(self):
    self.__rx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="rx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)


  def _get_tx_retries(self):
    """
    Getter method for tx_retries, mapped from YANG variable /ssids/ssid/clients/client/state/counters/tx_retries (oc-yang:counter64)

    YANG Description: Tx retried frames to this client.
    """
    return self.__tx_retries
      
  def _set_tx_retries(self, v, load=False):
    """
    Setter method for tx_retries, mapped from YANG variable /ssids/ssid/clients/client/state/counters/tx_retries (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_retries() directly.

    YANG Description: Tx retried frames to this client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_retries must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__tx_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_retries(self):
    self.__tx_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="tx-retries", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:counter64', is_config=False)

  tx_bytes = __builtin__.property(_get_tx_bytes)
  rx_bytes = __builtin__.property(_get_rx_bytes)
  rx_retries = __builtin__.property(_get_rx_retries)
  tx_retries = __builtin__.property(_get_tx_retries)


  _pyangbind_elements = {'tx_bytes': tx_bytes, 'rx_bytes': rx_bytes, 'rx_retries': rx_retries, 'tx_retries': tx_retries, }


class yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Client state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mac','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)
    self.__counters = YANGDynClass(base=yc_counters_openconfig_wifi_mac__ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'state']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /ssids/ssid/clients/client/state/mac (oc-yang:mac-address)

    YANG Description: MAC address of the client.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /ssids/ssid/clients/client/state/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /ssids/ssid/clients/client/state/counters (container)

    YANG Description: Per-client counters.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /ssids/ssid/clients/client/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: Per-client counters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_counters_openconfig_wifi_mac__ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_counters_openconfig_wifi_mac__ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=yc_counters_openconfig_wifi_mac__ssids_ssid_clients_client_state_counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  mac = __builtin__.property(_get_mac)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = {'mac': mac, 'counters': counters, }


class yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/client-rf/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RF related client state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__rssi','__snr','__ss','__phy_rate','__connection_mode','__frequency',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__connection_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__snr = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)
    self.__phy_rate = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'client-rf', u'state']

  def _get_rssi(self):
    """
    Getter method for rssi, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/rssi (int8)

    YANG Description: The RSSI of this client in dBm. Expressed as negative number
    """
    return self.__rssi
      
  def _set_rssi(self, v, load=False):
    """
    Setter method for rssi, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rssi() directly.

    YANG Description: The RSSI of this client in dBm. Expressed as negative number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)""",
        })

    self.__rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rssi(self):
    self.__rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)


  def _get_snr(self):
    """
    Getter method for snr, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/snr (uint8)

    YANG Description: The SNR of AP to Client, in dB.
    """
    return self.__snr
      
  def _set_snr(self, v, load=False):
    """
    Setter method for snr, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/snr (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snr() directly.

    YANG Description: The SNR of AP to Client, in dB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snr must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__snr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snr(self):
    self.__snr = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="snr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_ss(self):
    """
    Getter method for ss, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/ss (uint8)

    YANG Description: Number of Spatial Streams supported by the client.
    """
    return self.__ss
      
  def _set_ss(self, v, load=False):
    """
    Setter method for ss, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/ss (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ss() directly.

    YANG Description: Number of Spatial Streams supported by the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ss must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__ss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ss(self):
    self.__ss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_phy_rate(self):
    """
    Getter method for phy_rate, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/phy_rate (uint16)

    YANG Description: Last used PHY rate of connected client.
    """
    return self.__phy_rate
      
  def _set_phy_rate(self, v, load=False):
    """
    Setter method for phy_rate, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/phy_rate (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phy_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phy_rate() directly.

    YANG Description: Last used PHY rate of connected client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phy_rate must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__phy_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phy_rate(self):
    self.__phy_rate = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="phy-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_connection_mode(self):
    """
    Getter method for connection_mode, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/connection_mode (enumeration)

    YANG Description: 802.11 protocol used for the client's connection.
    """
    return self.__connection_mode
      
  def _set_connection_mode(self, v, load=False):
    """
    Setter method for connection_mode, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/connection_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_mode() directly.

    YANG Description: 802.11 protocol used for the client's connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-wifi-mac:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)""",
        })

    self.__connection_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_mode(self):
    self.__connection_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'A': {}, u'AC': {}, u'B': {}, u'G': {}, u'N': {}},), is_leaf=True, yang_name="connection-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='enumeration', is_config=False)


  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/frequency (uint8)

    YANG Description: Frequency the client is utilizing. Typically, 2.4 or 5[GHz].
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state/frequency (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency the client is utilizing. Typically, 2.4 or 5[GHz].
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

  rssi = __builtin__.property(_get_rssi)
  snr = __builtin__.property(_get_snr)
  ss = __builtin__.property(_get_ss)
  phy_rate = __builtin__.property(_get_phy_rate)
  connection_mode = __builtin__.property(_get_connection_mode)
  frequency = __builtin__.property(_get_frequency)


  _pyangbind_elements = {'rssi': rssi, 'snr': snr, 'ss': ss, 'phy_rate': phy_rate, 'connection_mode': connection_mode, 'frequency': frequency, }


class yc_client_rf_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/client-rf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RF radio-data per non-AP STA.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state',)

  _yang_name = 'client-rf'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'client-rf']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state (container)

    YANG Description: Container for RF related client state data.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/clients/client/client_rf/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for RF related client state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = {'state': state, }


class yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/client-capabilities/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Client capabilities, as reported by Assoc. Req. or
Probe Req. frames. Capability is supported, if present.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__client_capabilities','__channel_support',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__client_capabilities = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    self.__channel_support = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'client-capabilities', u'state']

  def _get_client_capabilities(self):
    """
    Getter method for client_capabilities, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities/state/client_capabilities (identityref)

    YANG Description: Features supported by client that are Optional
within the 802.11 specifications.
    """
    return self.__client_capabilities
      
  def _set_client_capabilities(self, v, load=False):
    """
    Setter method for client_capabilities, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities/state/client_capabilities (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_capabilities() directly.

    YANG Description: Features supported by client that are Optional
within the 802.11 specifications.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_capabilities must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)""",
        })

    self.__client_capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_capabilities(self):
    self.__client_capabilities = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'oc-wifi-types:MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMER': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOT_11R': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DOT_11V': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'MU_BEAMFORMEE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},)), is_leaf=False, yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)


  def _get_channel_support(self):
    """
    Getter method for channel_support, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities/state/channel_support (uint8)

    YANG Description: List of supported channels.
    """
    return self.__channel_support
      
  def _set_channel_support(self, v, load=False):
    """
    Setter method for channel_support, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities/state/channel_support (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_support() directly.

    YANG Description: List of supported channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_support must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__channel_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_support(self):
    self.__channel_support = YANGDynClass(base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="channel-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

  client_capabilities = __builtin__.property(_get_client_capabilities)
  channel_support = __builtin__.property(_get_channel_support)


  _pyangbind_elements = {'client_capabilities': client_capabilities, 'channel_support': channel_support, }


class yc_client_capabilities_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/client-capabilities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Capabilites as advertised by the Client.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state',)

  _yang_name = 'client-capabilities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'client-capabilities']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities/state (container)

    YANG Description: Container for Client capabilities, as reported by Assoc. Req. or
Probe Req. frames. Capability is supported, if present.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for Client capabilities, as reported by Assoc. Req. or
Probe Req. frames. Capability is supported, if present.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = {'state': state, }


class yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/dot11k-neighbors/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Client beacon reports. Requires 802.11k enabled.
See Sec. 5.2.7.1 of 802.11k-2008 Standard.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__neighbor_bssid','__neighbor_channel','__neighbor_rssi','__neighbor_antenna','__channel_load_report',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)
    self.__neighbor_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__neighbor_antenna = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    self.__neighbor_bssid = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)
    self.__channel_load_report = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'dot11k-neighbors', u'state']

  def _get_neighbor_bssid(self):
    """
    Getter method for neighbor_bssid, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_bssid (oc-yang:mac-address)

    YANG Description: The BSSID of this neighbor.
    """
    return self.__neighbor_bssid
      
  def _set_neighbor_bssid(self, v, load=False):
    """
    Setter method for neighbor_bssid, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_bssid (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_bssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_bssid() directly.

    YANG Description: The BSSID of this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_bssid must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__neighbor_bssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_bssid(self):
    self.__neighbor_bssid = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="neighbor-bssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-yang:mac-address', is_config=False)


  def _get_neighbor_channel(self):
    """
    Getter method for neighbor_channel, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_channel (uint8)

    YANG Description: The channel of this neighbor.
    """
    return self.__neighbor_channel
      
  def _set_neighbor_channel(self, v, load=False):
    """
    Setter method for neighbor_channel, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_channel (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_channel() directly.

    YANG Description: The channel of this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_channel must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__neighbor_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_channel(self):
    self.__neighbor_channel = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_neighbor_rssi(self):
    """
    Getter method for neighbor_rssi, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_rssi (int8)

    YANG Description: The RSSI of this neighbor in dBm, expressed as a negative number.
    """
    return self.__neighbor_rssi
      
  def _set_neighbor_rssi(self, v, load=False):
    """
    Setter method for neighbor_rssi, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_rssi() directly.

    YANG Description: The RSSI of this neighbor in dBm, expressed as a negative number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)""",
        })

    self.__neighbor_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_rssi(self):
    self.__neighbor_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="neighbor-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)


  def _get_neighbor_antenna(self):
    """
    Getter method for neighbor_antenna, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_antenna (uint8)

    YANG Description: Antenna details for this neighbor.
    """
    return self.__neighbor_antenna
      
  def _set_neighbor_antenna(self, v, load=False):
    """
    Setter method for neighbor_antenna, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/neighbor_antenna (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_antenna is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_antenna() directly.

    YANG Description: Antenna details for this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_antenna must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__neighbor_antenna = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_antenna(self):
    self.__neighbor_antenna = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="neighbor-antenna", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_channel_load_report(self):
    """
    Getter method for channel_load_report, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/channel_load_report (uint8)

    YANG Description: Channel load, as reported by Client to AP
normalized to 255. See Sec. 10.11.9.3 of 802.11ac-2013 Spec.
    """
    return self.__channel_load_report
      
  def _set_channel_load_report(self, v, load=False):
    """
    Setter method for channel_load_report, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state/channel_load_report (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_load_report is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_load_report() directly.

    YANG Description: Channel load, as reported by Client to AP
normalized to 255. See Sec. 10.11.9.3 of 802.11ac-2013 Spec.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_load_report must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__channel_load_report = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_load_report(self):
    self.__channel_load_report = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="channel-load-report", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

  neighbor_bssid = __builtin__.property(_get_neighbor_bssid)
  neighbor_channel = __builtin__.property(_get_neighbor_channel)
  neighbor_rssi = __builtin__.property(_get_neighbor_rssi)
  neighbor_antenna = __builtin__.property(_get_neighbor_antenna)
  channel_load_report = __builtin__.property(_get_channel_load_report)


  _pyangbind_elements = {'neighbor_bssid': neighbor_bssid, 'neighbor_channel': neighbor_channel, 'neighbor_rssi': neighbor_rssi, 'neighbor_antenna': neighbor_antenna, 'channel_load_report': channel_load_report, }


class yc_dot11k_neighbors_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/dot11k-neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 80211.k nieghbor information given from the Client to
the infrastructure.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state',)

  _yang_name = 'dot11k-neighbors'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'dot11k-neighbors']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state (container)

    YANG Description: Container for Client beacon reports. Requires 802.11k enabled.
See Sec. 5.2.7.1 of 802.11k-2008 Standard.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for Client beacon reports. Requires 802.11k enabled.
See Sec. 5.2.7.1 of 802.11k-2008 Standard.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = {'state': state, }


class yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/client-connection/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for connection state related data, per client.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__client_state','__connection_time','__username','__hostname','__ipv4_address','__ipv6_address','__operating_system',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=unicode, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__connection_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__hostname = YANGDynClass(base=unicode, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__operating_system = YANGDynClass(base=unicode, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    self.__client_state = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'client-connection', u'state']

  def _get_client_state(self):
    """
    Getter method for client_state, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/client_state (identityref)

    YANG Description: Various states a Client STA may be in.
    """
    return self.__client_state
      
  def _set_client_state(self, v, load=False):
    """
    Setter method for client_state, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/client_state (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_state() directly.

    YANG Description: Various states a Client STA may be in.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_state must be of a type compatible with identityref""",
          'defined-type': "openconfig-wifi-mac:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)""",
        })

    self.__client_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_state(self):
    self.__client_state = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_type="dict_key", restriction_arg={u'ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:BLACKLISTED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:ASSOCIATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_FAILURE_TIMEOUT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'POWERSAVE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:AUTHENTICATED': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_FAILURE': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L3AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'oc-wifi-types:L2AUTH_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'DHCP_REQD': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}, u'L2AUTH_FAILURE_REJECT': {'@namespace': u'http://openconfig.net/yang/wifi/types', '@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="client-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='identityref', is_config=False)


  def _get_connection_time(self):
    """
    Getter method for connection_time, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/connection_time (uint16)

    YANG Description: Time, in seconds, since Client Association.
    """
    return self.__connection_time
      
  def _set_connection_time(self, v, load=False):
    """
    Setter method for connection_time, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/connection_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_time() directly.

    YANG Description: Time, in seconds, since Client Association.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__connection_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection_time(self):
    self.__connection_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="connection-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)


  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/username (string)

    YANG Description: Username of Client; can be outer-identity (if PEAP),
CN of certificate (if EAP-TLS) etc.
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: Username of Client; can be outer-identity (if PEAP),
CN of certificate (if EAP-TLS) etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=unicode, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/hostname (string)

    YANG Description: Hostname of the client, as discovered via DHCP, mDNS
or otherwise.
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname of the client, as discovered via DHCP, mDNS
or otherwise.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=unicode, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)


  def _get_ipv4_address(self):
    """
    Getter method for ipv4_address, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/ipv4_address (oc-inet:ipv4-address)

    YANG Description: IPv4 address of the client.
    """
    return self.__ipv4_address
      
  def _set_ipv4_address(self, v, load=False):
    """
    Setter method for ipv4_address, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/ipv4_address (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_address() directly.

    YANG Description: IPv4 address of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_address must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_address(self):
    self.__ipv4_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/ipv6_address (oc-inet:ipv6-address)

    YANG Description: IPv6 address of the client.
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/ipv6_address (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: IPv6 address of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_operating_system(self):
    """
    Getter method for operating_system, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/operating_system (string)

    YANG Description: Optional/if known; the OS of the client.
    """
    return self.__operating_system
      
  def _set_operating_system(self, v, load=False):
    """
    Setter method for operating_system, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state/operating_system (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_system() directly.

    YANG Description: Optional/if known; the OS of the client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_system must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)""",
        })

    self.__operating_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_system(self):
    self.__operating_system = YANGDynClass(base=unicode, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='string', is_config=False)

  client_state = __builtin__.property(_get_client_state)
  connection_time = __builtin__.property(_get_connection_time)
  username = __builtin__.property(_get_username)
  hostname = __builtin__.property(_get_hostname)
  ipv4_address = __builtin__.property(_get_ipv4_address)
  ipv6_address = __builtin__.property(_get_ipv6_address)
  operating_system = __builtin__.property(_get_operating_system)


  _pyangbind_elements = {'client_state': client_state, 'connection_time': connection_time, 'username': username, 'hostname': hostname, 'ipv4_address': ipv4_address, 'ipv6_address': ipv6_address, 'operating_system': operating_system, }


class yc_client_connection_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client/client-connection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Connection-state and meta-data associated with the Client.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__state',)

  _yang_name = 'client-connection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client', u'client-connection']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state (container)

    YANG Description: Container for connection state related data, per client.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/clients/client/client_connection/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for connection state related data, per client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  state = __builtin__.property(_get_state)


  _pyangbind_elements = {'state': state, }


class yc_client_openconfig_wifi_mac__ssids_ssid_clients_client(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients/client. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of clients per BSS.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__mac','__state','__client_rf','__client_capabilities','__dot11k_neighbors','__client_connection',)

  _yang_name = 'client'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dot11k_neighbors = YANGDynClass(base=yc_dot11k_neighbors_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__client_connection = YANGDynClass(base=yc_client_connection_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__client_capabilities = YANGDynClass(base=yc_client_capabilities_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    self.__mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=False)
    self.__client_rf = YANGDynClass(base=yc_client_rf_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients', u'client']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /ssids/ssid/clients/client/mac (leafref)

    YANG Description: The clients WiFi MAC address.
    """
    return self.__mac
      
  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /ssids/ssid/clients/client/mac (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: The clients WiFi MAC address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/clients/client/state (container)

    YANG Description: Client state data.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/clients/client/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Client state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_clients_client_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_client_rf(self):
    """
    Getter method for client_rf, mapped from YANG variable /ssids/ssid/clients/client/client_rf (container)

    YANG Description: RF radio-data per non-AP STA.
    """
    return self.__client_rf
      
  def _set_client_rf(self, v, load=False):
    """
    Setter method for client_rf, mapped from YANG variable /ssids/ssid/clients/client/client_rf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_rf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_rf() directly.

    YANG Description: RF radio-data per non-AP STA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_client_rf_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_rf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_client_rf_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__client_rf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_rf(self):
    self.__client_rf = YANGDynClass(base=yc_client_rf_openconfig_wifi_mac__ssids_ssid_clients_client_client_rf, is_container='container', yang_name="client-rf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_client_capabilities(self):
    """
    Getter method for client_capabilities, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities (container)

    YANG Description: Capabilites as advertised by the Client.
    """
    return self.__client_capabilities
      
  def _set_client_capabilities(self, v, load=False):
    """
    Setter method for client_capabilities, mapped from YANG variable /ssids/ssid/clients/client/client_capabilities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_capabilities() directly.

    YANG Description: Capabilites as advertised by the Client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_client_capabilities_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_capabilities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_client_capabilities_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__client_capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_capabilities(self):
    self.__client_capabilities = YANGDynClass(base=yc_client_capabilities_openconfig_wifi_mac__ssids_ssid_clients_client_client_capabilities, is_container='container', yang_name="client-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_dot11k_neighbors(self):
    """
    Getter method for dot11k_neighbors, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors (container)

    YANG Description: 80211.k nieghbor information given from the Client to
the infrastructure.
    """
    return self.__dot11k_neighbors
      
  def _set_dot11k_neighbors(self, v, load=False):
    """
    Setter method for dot11k_neighbors, mapped from YANG variable /ssids/ssid/clients/client/dot11k_neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11k_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11k_neighbors() directly.

    YANG Description: 80211.k nieghbor information given from the Client to
the infrastructure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot11k_neighbors_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11k_neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot11k_neighbors_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__dot11k_neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11k_neighbors(self):
    self.__dot11k_neighbors = YANGDynClass(base=yc_dot11k_neighbors_openconfig_wifi_mac__ssids_ssid_clients_client_dot11k_neighbors, is_container='container', yang_name="dot11k-neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)


  def _get_client_connection(self):
    """
    Getter method for client_connection, mapped from YANG variable /ssids/ssid/clients/client/client_connection (container)

    YANG Description: Connection-state and meta-data associated with the Client.
    """
    return self.__client_connection
      
  def _set_client_connection(self, v, load=False):
    """
    Setter method for client_connection, mapped from YANG variable /ssids/ssid/clients/client/client_connection (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client_connection is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client_connection() directly.

    YANG Description: Connection-state and meta-data associated with the Client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_client_connection_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client_connection must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_client_connection_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)""",
        })

    self.__client_connection = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client_connection(self):
    self.__client_connection = YANGDynClass(base=yc_client_connection_openconfig_wifi_mac__ssids_ssid_clients_client_client_connection, is_container='container', yang_name="client-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=False)

  mac = __builtin__.property(_get_mac)
  state = __builtin__.property(_get_state)
  client_rf = __builtin__.property(_get_client_rf)
  client_capabilities = __builtin__.property(_get_client_capabilities)
  dot11k_neighbors = __builtin__.property(_get_dot11k_neighbors)
  client_connection = __builtin__.property(_get_client_connection)


  _pyangbind_elements = {'mac': mac, 'state': state, 'client_rf': client_rf, 'client_capabilities': client_capabilities, 'dot11k_neighbors': dot11k_neighbors, 'client_connection': client_connection, }


class yc_clients_openconfig_wifi_mac__ssids_ssid_clients(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/clients. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for clients operational state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__client',)

  _yang_name = 'clients'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__client = YANGDynClass(base=YANGListType("mac",yc_client_openconfig_wifi_mac__ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'clients']

  def _get_client(self):
    """
    Getter method for client, mapped from YANG variable /ssids/ssid/clients/client (list)

    YANG Description: List of clients per BSS.
    """
    return self.__client
      
  def _set_client(self, v, load=False):
    """
    Setter method for client, mapped from YANG variable /ssids/ssid/clients/client (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_client() directly.

    YANG Description: List of clients per BSS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mac",yc_client_openconfig_wifi_mac__ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """client must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mac",yc_client_openconfig_wifi_mac__ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)""",
        })

    self.__client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_client(self):
    self.__client = YANGDynClass(base=YANGListType("mac",yc_client_openconfig_wifi_mac__ssids_ssid_clients_client, yang_name="client", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)

  client = __builtin__.property(_get_client, _set_client)


  _pyangbind_elements = {'client': client, }


class yc_config_openconfig_wifi_mac__ssids_ssid_dot1x_timers_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot1x-timers/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for dot1x configuration elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__max_auth_failures','__blacklist_time',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot1x-timers', u'config']

  def _get_max_auth_failures(self):
    """
    Getter method for max_auth_failures, mapped from YANG variable /ssids/ssid/dot1x_timers/config/max_auth_failures (uint8)

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    return self.__max_auth_failures
      
  def _set_max_auth_failures(self, v, load=False):
    """
    Setter method for max_auth_failures, mapped from YANG variable /ssids/ssid/dot1x_timers/config/max_auth_failures (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_auth_failures is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_auth_failures() directly.

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_auth_failures must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)""",
        })

    self.__max_auth_failures = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_auth_failures(self):
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=True)


  def _get_blacklist_time(self):
    """
    Getter method for blacklist_time, mapped from YANG variable /ssids/ssid/dot1x_timers/config/blacklist_time (uint16)

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    return self.__blacklist_time
      
  def _set_blacklist_time(self, v, load=False):
    """
    Setter method for blacklist_time, mapped from YANG variable /ssids/ssid/dot1x_timers/config/blacklist_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_time() directly.

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blacklist_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)""",
        })

    self.__blacklist_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blacklist_time(self):
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=True)

  max_auth_failures = __builtin__.property(_get_max_auth_failures, _set_max_auth_failures)
  blacklist_time = __builtin__.property(_get_blacklist_time, _set_blacklist_time)


  _pyangbind_elements = {'max_auth_failures': max_auth_failures, 'blacklist_time': blacklist_time, }


class yc_state_openconfig_wifi_mac__ssids_ssid_dot1x_timers_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot1x-timers/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for dot1x state elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__max_auth_failures','__blacklist_time',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot1x-timers', u'state']

  def _get_max_auth_failures(self):
    """
    Getter method for max_auth_failures, mapped from YANG variable /ssids/ssid/dot1x_timers/state/max_auth_failures (uint8)

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    return self.__max_auth_failures
      
  def _set_max_auth_failures(self, v, load=False):
    """
    Setter method for max_auth_failures, mapped from YANG variable /ssids/ssid/dot1x_timers/state/max_auth_failures (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_auth_failures is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_auth_failures() directly.

    YANG Description: Number of consecutive authentication failures,
via RADIUS Access-Reject, before Station
is blacklisted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_auth_failures must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)""",
        })

    self.__max_auth_failures = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_auth_failures(self):
    self.__max_auth_failures = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-auth-failures", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint8', is_config=False)


  def _get_blacklist_time(self):
    """
    Getter method for blacklist_time, mapped from YANG variable /ssids/ssid/dot1x_timers/state/blacklist_time (uint16)

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    return self.__blacklist_time
      
  def _set_blacklist_time(self, v, load=False):
    """
    Setter method for blacklist_time, mapped from YANG variable /ssids/ssid/dot1x_timers/state/blacklist_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_time() directly.

    YANG Description: Length of time, in seconds, a Station will be
blacklisted as a result of max-auth-failures.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blacklist_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)""",
        })

    self.__blacklist_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blacklist_time(self):
    self.__blacklist_time = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="blacklist-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='uint16', is_config=False)

  max_auth_failures = __builtin__.property(_get_max_auth_failures)
  blacklist_time = __builtin__.property(_get_blacklist_time)


  _pyangbind_elements = {'max_auth_failures': max_auth_failures, 'blacklist_time': blacklist_time, }


class yc_dot1x_timers_openconfig_wifi_mac__ssids_ssid_dot1x_timers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/dot1x-timers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for dot1x configuration
and operational state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'dot1x-timers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'dot1x-timers']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ssids/ssid/dot1x_timers/config (container)

    YANG Description: Container for dot1x configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ssids/ssid/dot1x_timers/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for dot1x configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wifi_mac__ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_dot1x_timers_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/dot1x_timers/state (container)

    YANG Description: Container for dot1x state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/dot1x_timers/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for dot1x state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_dot1x_timers_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_config_openconfig_wifi_mac__ssids_ssid_band_steering_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/band-steering/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for band-steering configuration elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__band_steering','__steering_rssi',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'band-steering', u'config']

  def _get_band_steering(self):
    """
    Getter method for band_steering, mapped from YANG variable /ssids/ssid/band_steering/config/band_steering (boolean)

    YANG Description: Enable/disable band-steering.
    """
    return self.__band_steering
      
  def _set_band_steering(self, v, load=False):
    """
    Setter method for band_steering, mapped from YANG variable /ssids/ssid/band_steering/config/band_steering (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_band_steering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_band_steering() directly.

    YANG Description: Enable/disable band-steering.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """band_steering must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)""",
        })

    self.__band_steering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_band_steering(self):
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=True)


  def _get_steering_rssi(self):
    """
    Getter method for steering_rssi, mapped from YANG variable /ssids/ssid/band_steering/config/steering_rssi (int8)

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    return self.__steering_rssi
      
  def _set_steering_rssi(self, v, load=False):
    """
    Setter method for steering_rssi, mapped from YANG variable /ssids/ssid/band_steering/config/steering_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_steering_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_steering_rssi() directly.

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """steering_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=True)""",
        })

    self.__steering_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_steering_rssi(self):
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=True)

  band_steering = __builtin__.property(_get_band_steering, _set_band_steering)
  steering_rssi = __builtin__.property(_get_steering_rssi, _set_steering_rssi)


  _pyangbind_elements = {'band_steering': band_steering, 'steering_rssi': steering_rssi, }


class yc_state_openconfig_wifi_mac__ssids_ssid_band_steering_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/band-steering/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for band-steering state elements.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__band_steering','__steering_rssi',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'band-steering', u'state']

  def _get_band_steering(self):
    """
    Getter method for band_steering, mapped from YANG variable /ssids/ssid/band_steering/state/band_steering (boolean)

    YANG Description: Enable/disable band-steering.
    """
    return self.__band_steering
      
  def _set_band_steering(self, v, load=False):
    """
    Setter method for band_steering, mapped from YANG variable /ssids/ssid/band_steering/state/band_steering (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_band_steering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_band_steering() directly.

    YANG Description: Enable/disable band-steering.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """band_steering must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)""",
        })

    self.__band_steering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_band_steering(self):
    self.__band_steering = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='boolean', is_config=False)


  def _get_steering_rssi(self):
    """
    Getter method for steering_rssi, mapped from YANG variable /ssids/ssid/band_steering/state/steering_rssi (int8)

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    return self.__steering_rssi
      
  def _set_steering_rssi(self, v, load=False):
    """
    Setter method for steering_rssi, mapped from YANG variable /ssids/ssid/band_steering/state/steering_rssi (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_steering_rssi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_steering_rssi() directly.

    YANG Description: Minimum RSSI a dual-band Station's Probe Request
must be heard at on a 5GHz radio, in order for
band-steering to withhold 2.4GHz Probe Responses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """steering_rssi must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)""",
        })

    self.__steering_rssi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_steering_rssi(self):
    self.__steering_rssi = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="steering-rssi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='int8', is_config=False)

  band_steering = __builtin__.property(_get_band_steering)
  steering_rssi = __builtin__.property(_get_steering_rssi)


  _pyangbind_elements = {'band_steering': band_steering, 'steering_rssi': steering_rssi, }


class yc_band_steering_openconfig_wifi_mac__ssids_ssid_band_steering(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid/band-steering. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for band-steering configuration
and operational state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__config','__state',)

  _yang_name = 'band-steering'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid', u'band-steering']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ssids/ssid/band_steering/config (container)

    YANG Description: Container for band-steering configuration elements.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ssids/ssid/band_steering/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Container for band-steering configuration elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wifi_mac__ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_band_steering_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/band_steering/state (container)

    YANG Description: Container for band-steering state elements.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/band_steering/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Container for band-steering state elements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_band_steering_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = {'config': config, 'state': state, }


class yc_ssid_openconfig_wifi_mac__ssids_ssid(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids/ssid. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of named ssids on the APs.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__name','__config','__state','__wmm','__dot11r','__dot11v','__clients','__dot1x_timers','__band_steering',)

  _yang_name = 'ssid'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=True)
    self.__dot1x_timers = YANGDynClass(base=yc_dot1x_timers_openconfig_wifi_mac__ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__clients = YANGDynClass(base=yc_clients_openconfig_wifi_mac__ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__wmm = YANGDynClass(base=yc_wmm_openconfig_wifi_mac__ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__band_steering = YANGDynClass(base=yc_band_steering_openconfig_wifi_mac__ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__dot11v = YANGDynClass(base=yc_dot11v_openconfig_wifi_mac__ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    self.__dot11r = YANGDynClass(base=yc_dot11r_openconfig_wifi_mac__ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids', u'ssid']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ssids/ssid/name (leafref)

    YANG Description: References the configured name of the ssid
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ssids/ssid/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the configured name of the ssid
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /ssids/ssid/config (container)

    YANG Description: Configurable items at the global, ssid level
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /ssids/ssid/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configurable items at the global, ssid level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_wifi_mac__ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_wifi_mac__ssids_ssid_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ssids/ssid/state (container)

    YANG Description: Operational state data at the ssid level
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ssids/ssid/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data at the ssid level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_wifi_mac__ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_wifi_mac__ssids_ssid_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_wmm(self):
    """
    Getter method for wmm, mapped from YANG variable /ssids/ssid/wmm (container)

    YANG Description: Top-level container for WMM configuration and
state container.
    """
    return self.__wmm
      
  def _set_wmm(self, v, load=False):
    """
    Setter method for wmm, mapped from YANG variable /ssids/ssid/wmm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wmm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wmm() directly.

    YANG Description: Top-level container for WMM configuration and
state container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_wmm_openconfig_wifi_mac__ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wmm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_wmm_openconfig_wifi_mac__ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__wmm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wmm(self):
    self.__wmm = YANGDynClass(base=yc_wmm_openconfig_wifi_mac__ssids_ssid_wmm, is_container='container', yang_name="wmm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_dot11r(self):
    """
    Getter method for dot11r, mapped from YANG variable /ssids/ssid/dot11r (container)

    YANG Description: Top-level container for 802.11r configuration and
state container.
    """
    return self.__dot11r
      
  def _set_dot11r(self, v, load=False):
    """
    Setter method for dot11r, mapped from YANG variable /ssids/ssid/dot11r (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11r is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11r() directly.

    YANG Description: Top-level container for 802.11r configuration and
state container.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot11r_openconfig_wifi_mac__ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11r must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot11r_openconfig_wifi_mac__ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__dot11r = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11r(self):
    self.__dot11r = YANGDynClass(base=yc_dot11r_openconfig_wifi_mac__ssids_ssid_dot11r, is_container='container', yang_name="dot11r", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_dot11v(self):
    """
    Getter method for dot11v, mapped from YANG variable /ssids/ssid/dot11v (container)

    YANG Description: Top-level container for 802.11v configuration and
operational state data.
    """
    return self.__dot11v
      
  def _set_dot11v(self, v, load=False):
    """
    Setter method for dot11v, mapped from YANG variable /ssids/ssid/dot11v (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot11v is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot11v() directly.

    YANG Description: Top-level container for 802.11v configuration and
operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot11v_openconfig_wifi_mac__ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot11v must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot11v_openconfig_wifi_mac__ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__dot11v = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot11v(self):
    self.__dot11v = YANGDynClass(base=yc_dot11v_openconfig_wifi_mac__ssids_ssid_dot11v, is_container='container', yang_name="dot11v", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_clients(self):
    """
    Getter method for clients, mapped from YANG variable /ssids/ssid/clients (container)

    YANG Description: Top-level container for clients operational state data.
    """
    return self.__clients
      
  def _set_clients(self, v, load=False):
    """
    Setter method for clients, mapped from YANG variable /ssids/ssid/clients (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clients is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clients() directly.

    YANG Description: Top-level container for clients operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clients_openconfig_wifi_mac__ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clients must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clients_openconfig_wifi_mac__ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__clients = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clients(self):
    self.__clients = YANGDynClass(base=yc_clients_openconfig_wifi_mac__ssids_ssid_clients, is_container='container', yang_name="clients", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_dot1x_timers(self):
    """
    Getter method for dot1x_timers, mapped from YANG variable /ssids/ssid/dot1x_timers (container)

    YANG Description: Top-level container for dot1x configuration
and operational state data.
    """
    return self.__dot1x_timers
      
  def _set_dot1x_timers(self, v, load=False):
    """
    Setter method for dot1x_timers, mapped from YANG variable /ssids/ssid/dot1x_timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot1x_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot1x_timers() directly.

    YANG Description: Top-level container for dot1x configuration
and operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot1x_timers_openconfig_wifi_mac__ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot1x_timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot1x_timers_openconfig_wifi_mac__ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__dot1x_timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot1x_timers(self):
    self.__dot1x_timers = YANGDynClass(base=yc_dot1x_timers_openconfig_wifi_mac__ssids_ssid_dot1x_timers, is_container='container', yang_name="dot1x-timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)


  def _get_band_steering(self):
    """
    Getter method for band_steering, mapped from YANG variable /ssids/ssid/band_steering (container)

    YANG Description: Top-level container for band-steering configuration
and operational state data.
    """
    return self.__band_steering
      
  def _set_band_steering(self, v, load=False):
    """
    Setter method for band_steering, mapped from YANG variable /ssids/ssid/band_steering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_band_steering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_band_steering() directly.

    YANG Description: Top-level container for band-steering configuration
and operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_band_steering_openconfig_wifi_mac__ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """band_steering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_band_steering_openconfig_wifi_mac__ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__band_steering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_band_steering(self):
    self.__band_steering = YANGDynClass(base=yc_band_steering_openconfig_wifi_mac__ssids_ssid_band_steering, is_container='container', yang_name="band-steering", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  wmm = __builtin__.property(_get_wmm, _set_wmm)
  dot11r = __builtin__.property(_get_dot11r, _set_dot11r)
  dot11v = __builtin__.property(_get_dot11v, _set_dot11v)
  clients = __builtin__.property(_get_clients, _set_clients)
  dot1x_timers = __builtin__.property(_get_dot1x_timers, _set_dot1x_timers)
  band_steering = __builtin__.property(_get_band_steering, _set_band_steering)


  _pyangbind_elements = {'name': name, 'config': config, 'state': state, 'wmm': wmm, 'dot11r': dot11r, 'dot11v': dot11v, 'clients': clients, 'dot1x_timers': dot1x_timers, 'band_steering': band_steering, }


class yc_ssids_openconfig_wifi_mac__ssids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /ssids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for ssids, including configuration
and state data.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__ssid',)

  _yang_name = 'ssids'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssid = YANGDynClass(base=YANGListType("name",yc_ssid_openconfig_wifi_mac__ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'ssids']

  def _get_ssid(self):
    """
    Getter method for ssid, mapped from YANG variable /ssids/ssid (list)

    YANG Description: The list of named ssids on the APs.
    """
    return self.__ssid
      
  def _set_ssid(self, v, load=False):
    """
    Setter method for ssid, mapped from YANG variable /ssids/ssid (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssid() directly.

    YANG Description: The list of named ssids on the APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_ssid_openconfig_wifi_mac__ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssid must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_ssid_openconfig_wifi_mac__ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)""",
        })

    self.__ssid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssid(self):
    self.__ssid = YANGDynClass(base=YANGListType("name",yc_ssid_openconfig_wifi_mac__ssids_ssid, yang_name="ssid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ssid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='list', is_config=True)

  ssid = __builtin__.property(_get_ssid, _set_ssid)


  _pyangbind_elements = {'ssid': ssid, }


class openconfig_wifi_mac(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /openconfig-wifi-mac. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing MAC layer configuration of Radio interfaces.
  """
  __slots__ = ('_pybind_generated_by', '_path_helper', '_yang_name', '_extmethods', '__ssids',)

  _yang_name = 'openconfig-wifi-mac'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssids = YANGDynClass(base=yc_ssids_openconfig_wifi_mac__ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ssids(self):
    """
    Getter method for ssids, mapped from YANG variable /ssids (container)

    YANG Description: Top level container for ssids, including configuration
and state data.
    """
    return self.__ssids
      
  def _set_ssids(self, v, load=False):
    """
    Setter method for ssids, mapped from YANG variable /ssids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssids() directly.

    YANG Description: Top level container for ssids, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ssids_openconfig_wifi_mac__ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ssids_openconfig_wifi_mac__ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__ssids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssids(self):
    self.__ssids = YANGDynClass(base=yc_ssids_openconfig_wifi_mac__ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  ssids = __builtin__.property(_get_ssids, _set_ssids)


  _pyangbind_elements = {'ssids': ssids, }


